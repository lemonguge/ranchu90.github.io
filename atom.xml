<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[cd's blog]]></title>
  <link href="http://ranchu90.github.io/atom.xml" rel="self"/>
  <link href="http://ranchu90.github.io/"/>
  <updated>2016-09-28T18:19:18+08:00</updated>
  <id>http://ranchu90.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[16. Java面向对象的三个特征与含义]]></title>
    <link href="http://ranchu90.github.io/14751214147355.html"/>
    <updated>2016-09-29T11:56:54+08:00</updated>
    <id>http://ranchu90.github.io/14751214147355.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">封装</h3>

<p>封装：Java将现实中的对象抽象成一个类，并对它的属性和方法进行屏蔽保护，只允许特定的类可以访问，其它的进行隐藏，这个过程叫做封装。</p>

<h3 id="toc_1">继承</h3>

<p>继承：当两个类的关系是is-a的时候，可以考虑使用继承。它是一种层次结构，类的重用方式。当一个新类从现有类中派生出来，这个过程叫做继承。新类继承了原有类的属性和方法。缺点是继承树过于庞大之后,会导致子类继承后负担重,很多不需要的成员变量也被继承下来,整个类结构过于臃肿。</p>

<h3 id="toc_2">多态</h3>

<p>多态：允许不同类的对象对同一消息做出不同的响应。灵活抽象行为共享的优势。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>

<p>多态存在的三个必要条件<br/>
一、要有继承；<br/>
二、要有重写；<br/>
三、父类引用指向子类对象。</p>

<pre><code>class A {
    public void show(){
        System.out.println(&quot;This is A.&quot;);
    }
}

class B extends A{
    public void show(){
        System.out.println(&quot;This is B.&quot;);
    }
}

class C extends A{
    public void show(){
        System.out.println(&quot;This is C.&quot;);
    }
}

class Main {
    public static void main(String[] args) {
        A a = new A();
        a.show();
        A b = new B();
        b.show();
        A c = new C();
        c.show(); 
    }
}
</code></pre>

<p>输出</p>

<pre><code>This is A.
This is B.
This is C.
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[15. Exception与Error包结构。常见的OOM和SOF]]></title>
    <link href="http://ranchu90.github.io/14751149362443.html"/>
    <updated>2016-09-29T10:08:56+08:00</updated>
    <id>http://ranchu90.github.io/14751149362443.html</id>
    <content type="html"><![CDATA[
<p><img src="media/14751149362443/14751149641985.jpg" alt=""/></p>

<p>Java提供了两种错误的异常，分别为Exception和Error，它们继承自共同的父类Throwable。</p>

<h2 id="toc_0">Error</h2>

<p>Error表示程序在运行期间出现了非常严重的错误，且这个错误是不可恢复的。将导致程序终止执行。如OutOfMemoryError、ThreadDeath。错误发生时，JVM一般会终止程序的运行。</p>

<h2 id="toc_1">Exception</h2>

<p>Exception表示可恢复的异常，编译可以捕获。</p>

<p>1.检查异常（checked exception）<br/>
编译阶段发生，编译器强制在程序里捕获这类异常，放入try代码块中，把对异常的处理代码放到catch块中。常见的有IOException和SQLException。一般在以下情况中使用：<br/>
1）异常的发生并不导致程序出错，进行处理后可以继续执行后续的操作。<br/>
2）程序依赖于不可靠的外部条件，如IO。</p>

<p>2.运行时异常（runtime exception）<br/>
编译器不强制进行捕获。若不捕获的话，由JVM来处理。常见的运行时异常包括NullPointerException、ClassCastException、ArrayIndexOutOfBoundsException、StoreException、BufferOverflowException、ArithmeticException。</p>

<p>出现运行时异常之后，系统会将异常一直往上次抛出，知道遇到处理代码位置。若没有处理代码，则抛到最上层。多线程run()方法抛出，线程终止，或单线程main()方法抛出，整个程序退出。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[14. try catch finally，try里有return，finally还执行么]]></title>
    <link href="http://ranchu90.github.io/14750561415107.html"/>
    <updated>2016-09-28T17:49:01+08:00</updated>
    <id>http://ranchu90.github.io/14750561415107.html</id>
    <content type="html"><![CDATA[
<p>finally中的内容一定会执行的</p>

<pre><code>try{
    return 0;
} catch(Exception e){
    return 1;
} finally{
    return 2;
}
</code></pre>

<p>finally中的return会覆盖try，catch中的return，所以最后返回的是finally中的值</p>

<pre><code>class Main{
    public static String lem(){
        System.out.println(&quot;lem&quot;);
        return &quot;return from lem&quot;;
    }
    
    public static String foo(){
        int x = 0;
        int y = 5;
        try {
            System.out.println(&quot;start try&quot;);
            int b = y/x;
            System.out.println(&quot;end try&quot;);
            return &quot;return from try&quot;;
        } catch (Exception e) {
            System.out.println(&quot;catch&quot;);
            return lem() + &quot;| return from catch&quot;;
        } finally {
            System.out.println(&quot;finally&quot;);
            return &quot;return from finally&quot;;
        }
    }
    
    public static void main(String[] args) {
        String v = foo();
        
        System.out.println(v);
    }
}
</code></pre>

<p>输出：</p>

<pre><code>start try
catch
lem
finally
return from finally
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[12. TreeMap、HashMap、LinkedHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14750544918726.html"/>
    <updated>2016-09-28T17:21:31+08:00</updated>
    <id>http://ranchu90.github.io/14750544918726.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>TreeMap</th>
<th>LinkedHashMap</th>
</tr>
</thead>

<tbody>
<tr>
<td>遍历顺序</td>
<td>随机</td>
<td>实现了sortMap接口，按自然顺序或自定义顺序</td>
<td>与输入顺序相同</td>
</tr>
</tbody>
</table>

<p>weakHashMap与HashMap类似，它从用若引用，其中key不再被外部引用时即被JVM回收，HashMap采用强引用，key不被外部引用时，必须从Map中删除才能被GC回收</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[11. HashMap、Hashtable、ConcurrentHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14749678612341.html"/>
    <updated>2016-09-27T17:17:41+08:00</updated>
    <id>http://ranchu90.github.io/14749678612341.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">多线程下的HashMap</h2>

<p>HashMap是线程不安全的，在多线程环境中并发操作会存在以下问题：</p>

<ul>
<li>  多线程使用put()，触发resize(rehash)操作，创建多个newTable，再同时rehash，导致链表错乱。这时候，再使用get()操作将进入无线循环。getEntry获取table中的链表，链表成了一个循环链表，所以进入无线循环。</li>
</ul>

<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>

<ul>
<li>remove()，遍历map时调用remove，可能会导致丢失删除的数据后面的数据，跳到下一个槽位。</li>
</ul>

<h2 id="toc_1">ConcurrentHashMap和Hashtable</h2>

<p>concurrent,同时发生的。同时发生的hashmap，从名字就可以知道它专门用于多线程的情况。<br/>
它不同于hashtable，hashtable在方法前使用synchronized来保证同步这会导致被当一个对象被锁住的时候，另一个线程无法使用get()方法，而ConcurrentHashMap对map进行分段，在插入时使用段（继承自重用锁），来实现线程之间的同步。<br/>
但是在最新的java源码里我看到的是在put方法中使用synchronized块来实现同步。</p>

<pre><code> /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
</code></pre>

<p>以下三篇文章中有详细的说明可以参考下</p>

<p><a href="http://ifeve.com/concurrenthashmap/">http://ifeve.com/concurrenthashmap/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-1/">http://ifeve.com/java-concurrent-hashmap-1/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-2/">http://ifeve.com/java-concurrent-hashmap-2/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10. HashMap和HashTable的区别]]></title>
    <link href="http://ranchu90.github.io/14749657860314.html"/>
    <updated>2016-09-27T16:43:06+08:00</updated>
    <id>http://ranchu90.github.io/14749657860314.html</id>
    <content type="html"><![CDATA[
<p>Map<br/>
├Hashtable<br/>
├HashMap<br/>
└WeakHashMap</p>

<p>HashMap和HashTable都是Java中哈希表的实现方式。其中HashTable里的大多数方法比如add、remove..等前有synchronized修饰，所以它在多线程的环境下是线程安全的，也因此需要耗费性能在同步的问题上。而HashMap不是，所以它的效率较HashTable高。<br/>
HashMap中可以使用null作为key，这在HashTable中是不允许的。<br/>
HashMap中的contains方法因为语义不明改为containsKey()和containsValue()。<br/>
(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>

<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>

<tbody>
<tr>
<td>null作为key</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>contains()</td>
<td>改为containsKey() constainsValue()</td>
<td>继承Dicitionary</td>
</tr>
<tr>
<td>线程安全</td>
<td>否 效率较高</td>
<td>是 效率较低</td>
</tr>
<tr>
<td>迭代</td>
<td>iterator</td>
<td>enumeration</td>
</tr>
<tr>
<td>hash性能</td>
<td>几乎一样 使用hashcode()方法</td>
<td></td>
</tr>
<tr>
<td>hash值</td>
<td>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</td>
<td>直接hashcode方法的值</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9. Map、Set、List、Queue、Stack的特点与用法]]></title>
    <link href="http://ranchu90.github.io/14749474920939.html"/>
    <updated>2016-09-27T11:38:12+08:00</updated>
    <id>http://ranchu90.github.io/14749474920939.html</id>
    <content type="html"><![CDATA[
<p>Collections框架中包含了大量的集合接口及这些接口的实现。主要提供了9种Map、Set、List、Queue、Stack等数据结构。</p>

<ul>
<li>Set接口表示数学中集合的概念。其主要特点是集合中的元素不重复。</li>
<li>List接口表示有序的集合。它按照对象进入的顺序保存对象，所以能对每个元素的插入和删除具体的位置进行精确的控制。它能存放重复的对象。</li>
<li>Map接口提供了一个从Key到Value的数据结构，保存键值对。其中Value可以重复，但是Key不能重复。</li>
<li>Queue接口提供了“先进先出”队列的数据结构。只能在队尾添加元素，只能在对头弹出元素。</li>
<li>Stack继承自Vector，它实现了先进后出的栈结构。</li>
</ul>

<p>我在网络上找到一张实现Collection接口的类图，可以一目了然地看到实现的类及他们之间的关系。<br/>
<img src="media/14749474920939/14749600076300.jpg" alt=""/></p>

<p>Collection接口定义了一套统一的操作方法：</p>

<pre><code>int size();
返回容器中元素的个数
boolean isEmpty();
判断容器是否为空，空则返回true，否则false
boolean contains(Object o);
判段容器是否包含o对象
Iterator&lt;E&gt; iterator();
获得该容器的迭代器
Object[] toArray();
将容器转换为对象数组
boolean add(E e);
向容器中添加元素
boolean remove(Object o);
移除容器中的对象
boolean containsAll(Collection&lt;?&gt; c);
判断是否包含c中的所有元素
boolean addAll(Collection&lt;? extends E&gt; c);
添加c容器中的所有元素
boolean removeAll(Collection&lt;?&gt; c);
移除c中包含的所有元素
boolean retainAll(Collection&lt;?&gt; c);
保留c中存在的元素，移除c中不存在的元素
void clear();
清除容器中的所有元素
</code></pre>

<p>Stack类中除了继承了Vector的方法外还实现了</p>

<pre><code>boolean empty() 
测试堆栈是否为空。
Object peek( )
查看堆栈顶部的对象，但不从堆栈中移除它。
Object pop( )
移除堆栈顶部的对象，并作为此函数的值返回该对象。
Object push(Object element)
把项压入堆栈顶部。
int search(Object element)
返回对象在堆栈中的位置，以 1 为基数。
</code></pre>

<p>Queue类中常用方法</p>

<pre><code>boolean add(E e);        
增加一个元素              若队列已满，则抛出一个IIIegaISlabEepeplian异常
boolean remove();   
移除并返回队列头部的元素    若队列为空，则抛出一个NoSuchElementException异常
E element()  
返回队列头部的元素         若队列为空，则抛出一个NoSuchElementException异常
offer(E e)      
添加一个元素并返回true     若队列已满，则返回false
E poll()      
移除并返问队列头部的元素    若队列为空，则返回null
E peek()     
返回队列头部的元素         若队列为空，则返回null
void put()     
添加一个元素              若队列满，则阻塞
void take()
移除并返回队列头部的元素    若队列为空，则阻塞
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[8. String、StringBuffer与StringBuilder的区别]]></title>
    <link href="http://ranchu90.github.io/14749467173553.html"/>
    <updated>2016-09-27T11:25:17+08:00</updated>
    <id>http://ranchu90.github.io/14749467173553.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>

<tbody>
<tr>
<td>可变性</td>
<td>不可变类</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td>线程安全</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>适用场合</td>
<td>被共享的场合 少量数据</td>
<td>经常修改的场合 避免附加操作 无用对象 提高效率 多线程大量数据</td>
<td>单线程下大量数据</td>
</tr>
<tr>
<td>构建</td>
<td>构造函数 ==赋值</td>
<td>构造函数</td>
<td>构造函数</td>
</tr>
<tr>
<td>执行效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7. ArrayList、LinkedList、Vector的区别]]></title>
    <link href="http://ranchu90.github.io/14748992011687.html"/>
    <updated>2016-09-26T22:13:21+08:00</updated>
    <id>http://ranchu90.github.io/14748992011687.html</id>
    <content type="html"><![CDATA[
<p>Collection包结构，Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法。实现该接口的类主要有List和Set，其目的在于为各种具体的集合提供最大化的统一的操作方式。<br/>
Collection包结构</p>

<pre><code>Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set
</code></pre>

<p>ArrayList和Vector是顺序存储（物理上连续的内存空间）的集合，使用的时候可以根据下标进行访问，索引数据的效率高。但是在删除或者插入时，需要移动容器中的元素，因此插入删除时，效率低。<br/>
另外，Vector的大多数方法前都有synchronized关键字，因此是线程安全的，ArrayList则不是。</p>

<p>容量扩充：当ArrayList或Vector中设定的容量不够容纳新的节点时，会自动调用grow()方法进行容量的扩充。ArrayList默认扩充原来大小的1.5倍。Vector默认扩充原来大小的2倍，指定capacityIncrement的话，每次扩充指定的大小。</p>

<pre><code>//ArrayList
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
//LinkedList
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
</code></pre>

<p>LinkedList采用双向链表实现，无法使用下标访问。每次由下标获取元素的时候，先判断其在前半段还是后半段，在前半段从头结点开始查找，在后半段从尾节点从后往前查找。因此，查找时，效率较ArrayList和Vector低。但是插入或者删除操作，只需要进行节点的删除或者连接操作，因此效率较前二者高。</p>

<pre><code>Node&lt;E&gt; node(int index) {
        // assert isElementIndex(index);

        if (index &lt; (size &gt;&gt; 1)) {
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6. Hashcode的作用]]></title>
    <link href="http://ranchu90.github.io/14748977980780.html"/>
    <updated>2016-09-26T21:49:58+08:00</updated>
    <id>http://ranchu90.github.io/14748977980780.html</id>
    <content type="html"><![CDATA[
<p>1.在HashMap、HashTable..等集合类中，采用邻接矩阵的数据结构实现，hashCode()值用来散列存储结构中确定对象的存储地址。</p>

<p>2.找到目标地址后，在链表的遍历中使用equals()方法判断两个对象的内容是否相同。</p>

<p>3.如果equals()被重写，那么该对象的hashCode()也要被重写，以保证2中的条件成立。</p>

<p>4.由邻接矩阵的结构可知，hashCode值相同的对象，其内容不一定相同，只能说明他们存放在同一条链表中。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5. Java的四种引用，强弱软虚，用到的场景]]></title>
    <link href="http://ranchu90.github.io/14748971773098.html"/>
    <updated>2016-09-26T21:39:37+08:00</updated>
    <id>http://ranchu90.github.io/14748971773098.html</id>
    <content type="html"><![CDATA[
<p>Java对对象的引用分为四种：<br/>
1.强引用。强引用的对象不会被垃圾回收器回收。内存不足时，宁可抛出OOM错误也不会回收强引用。</p>

<p>2.软引用。可有可无的引用，当JVM内存足够的时候不会被回收；当JVM内存不足的时候，发现软引用的存在，会回收软引用。</p>

<p>3.若引用。可有可无的引用，一旦被垃圾回收器发现，马上就被其回收。</p>

<p>4.幽灵引用。它一般用来标记被回收的对象，当对象被回收后，会受到一条消息。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4.Object有哪些公用方法？]]></title>
    <link href="http://ranchu90.github.io/14748970236814.html"/>
    <updated>2016-09-26T21:37:03+08:00</updated>
    <id>http://ranchu90.github.io/14748970236814.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1．clone方法</h2>

<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>

<h2 id="toc_1">2．getClass方法</h2>

<p>final方法，获得运行时类型。</p>

<h2 id="toc_2">3．toString方法</h2>

<p>该方法用得比较多，一般子类都有覆盖。</p>

<h2 id="toc_3">4．finalize方法</h2>

<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。自动垃圾收集 器 会 调用 finalize() 方法。</p>

<h2 id="toc_4">5．equals方法</h2>

<p>该方法是非常重要的一个方法。一般equals和<code>==</code>是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>

<h2 id="toc_5">6．hashCode方法</h2>

<p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。<br/>
一般必须满足obj1.equals(obj2)<code>==</code>true。可以推出obj1.hashCode()<code>==</code>obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>

<h2 id="toc_6">7．wait方法</h2>

<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br/>
调用该方法后当前线程进入睡眠状态，直到以下事件发生。<br/>
（1）其他线程调用了该对象的notify方法。<br/>
（2）其他线程调用了该对象的notifyAll方法。<br/>
（3）其他线程调用了interrupt中断该线程。<br/>
（4）时间间隔到了。<br/>
此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>

<h2 id="toc_7">8．notify方法</h2>

<p>该方法唤醒在该对象上等待的某个线程。</p>

<h2 id="toc_8">9．notifyAll方法</h2>

<p>该方法唤醒在该对象上等待的所有线程。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3.equals()和==的区别]]></title>
    <link href="http://ranchu90.github.io/14748960344939.html"/>
    <updated>2016-09-26T21:20:34+08:00</updated>
    <id>http://ranchu90.github.io/14748960344939.html</id>
    <content type="html"><![CDATA[
<p><code>==</code>用于判断两边的变量的值是否相等，如果是基本数据类型，就是判断他们的值是不是相等；如果<code>==</code>两边是对象的引用，那么指的是这两个引用是否指向同一个对象，及引用的值是否相等。</p>

<p><code>equals()</code>是Object里的方法。在Object的equals中，就是使用<code>==</code>来进行比较，比较的是引用。与<code>==</code>不同的是，在某些Object的子类中，覆盖了equals()方法，比如String中的equals()方法比较两个字符串对象的内容是否相同。</p>

<p><code>hashCode()</code>方法也是继承自Object，它用来获取一个对象的hash值，返回int值。Object.hashCode规定，equals()相等的对象，它们的HashCode()返回值也必须相等，否则无法与集合类结合在一起使用。(List, Set, Hashmap..)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2.  Switch能否用String做参数？]]></title>
    <link href="http://ranchu90.github.io/14748943230133.html"/>
    <updated>2016-09-26T20:52:03+08:00</updated>
    <id>http://ranchu90.github.io/14748943230133.html</id>
    <content type="html"><![CDATA[
<p>1.jdk1.7之前只能使用int型作为参数，byte、short会自动转换成int进行比较。<br/>
2.在jdk 1.7之前，无法使用String作为参数。1.7以后加入。<br/>
原理：hashCode()+equals()<br/>
编译器在编译期间给代码做了转换。<br/>
原始：</p>

<pre><code>public class StringInSwitchCase { 
      public static void main(String[] args) { 
            String mode = args[0]; 
            switch (mode) { 
                  case &quot;ACTIVE&quot;: 
                        System.out.println(&quot;Application is running on Active mode&quot;); 
                        break; 
                  case &quot;PASSIVE&quot;:
                        System.out.println(&quot;Application is running on Passive mode&quot;); 
                         break; 
                  case &quot;SAFE&quot;: 
                          System.out.println(&quot;Application is running on Safe mode&quot;); 
          } 
      } 
}
</code></pre>

<p>编译器优化后：</p>

<pre><code>import java.io.PrintStream; 
 
public class StringInSwitchCase{ 
      public StringInSwitchCase() { } 
 
      public static void main(string args[]) { 
             String mode = args[0]; 
            String s; switch ((s = mode).hashCode()) { 
                  default: break; 
                  case -74056953: 
                        if (s.equals(&quot;PASSIVE&quot;)) { 
                                    System.out.println(&quot;Application is running on Passive mode&quot;); 
                         } 
                        break; 
                  case 2537357: 
                        if (s.equals(&quot;SAFE&quot;)) { 
                              System.out.println(&quot;Application is running on Safe mode&quot;); 
                         } 
                        break; 
                  case 1925346054: 
                        if (s.equals(&quot;ACTIVE&quot;)) { 
                              System.out.println(&quot;Application is running on Active mode&quot;); 
                         } 
                        break; 
               } 
          } 
}
</code></pre>

<p>参考资料：<br/>
<a href="http://www.importnew.com/14597.html">http://www.importnew.com/14597.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1.	九种基本数据类型的大小，以及他们的封装类]]></title>
    <link href="http://ranchu90.github.io/14748770602290.html"/>
    <updated>2016-09-26T16:04:20+08:00</updated>
    <id>http://ranchu90.github.io/14748770602290.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>包装类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>boolean</td>
<td>32-bit</td>
<td>-</td>
<td>-</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16-bit</td>
<td>Unicode 0</td>
<td>Unicode 2<sup>16</sup> -1</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8-bit</td>
<td>-2<sup>7</sup></td>
<td>2<sup>7</sup> -1</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16-bit</td>
<td>-2<sup>15</sup></td>
<td>2<sup>15</sup> -1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32-bit</td>
<td>-2<sup>31</sup></td>
<td>2<sup>31</sup> -1</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64-bit</td>
<td>-2<sup>63</sup></td>
<td>2<sup>63</sup> -1</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32-bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64-bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody>
</table>

<h2 id="toc_0">使用封装类的目的</h2>

<p>集合类中存放的都是对象，为了使集合类也能存放基本数据类型，Java提供了其对应的包装类。</p>

<h2 id="toc_1">封装类与基本数据类型的区别</h2>

<ol>
<li>传递类型不同，封装类是引用传递，基本数据类型是值传递。</li>
<li>内存分配不同，类在堆上分配，基本类型在Java虚拟栈上分配。</li>
</ol>

<h2 id="toc_2">void类型</h2>

<p>Java编程思想中奖void也纳入基本数据类型。Java文档中对void的解释:</p>

<pre><code>/**
 * The {@code Void} class is an uninstantiable placeholder class to hold a
 * reference to the {@code Class} object representing the Java keyword
 * void.
 *
 * @author  unascribed
 * @since   JDK1.1
 */
</code></pre>

<p>java.lang.Void 类是一个不可实例化的占位符类来保存一个引用代表了Java关键字void的Class对象。Void无法通过new在堆中分配空间。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[J2SE基础问题汇总]]></title>
    <link href="http://ranchu90.github.io/14748751468195.html"/>
    <updated>2016-09-26T15:32:26+08:00</updated>
    <id>http://ranchu90.github.io/14748751468195.html</id>
    <content type="html"><![CDATA[
<pre><code>1.  九种基本数据类型的大小，以及他们的封装类
2.  Switch能否用string做参数？
3. equals()与==的区别
4. Object有哪些公用方法？
5. Java的四种引用，强弱软虚，用到的场景。
6. Hashcode的作用
7. ArrayList、LinkedList、Vector的区别
8. String、StringBuffer与StringBuilder的区别
9. Map、Set、List、Queue、Stack的特点与用法
10. HashMap和HashTable的区别
11. HashMap和ConcurrentHashMap的区别
12. TreeMap、HashMap、LinkedHashMap的区别。
13. Collection包结构，与Collections的区别
14. try catch finally，try里有return，finally还执行么
15. Exception与Error包结构。常见的OOM和SOF。
16. Java面向对象的三个特征与含义
17. Override和Overload的含义去区别
18. Interface与abstract类的区别
19. Static inner class 与non static inner class的区别
20. Java多态的实现原理
21. 实现多线程的两种方法：Thread与Runable
22. 线程同步的方法：synchronized、lock、reentrantLock等
23. 锁的等级：方法锁、对象锁、类锁。
24. 写出生产者消费者模式。
25. ThreadLocal的设计理念与作用。
26. ThreadPool用法与优势。
27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等
28. wait()和sleep()的区别
29. foreach与正常for循环效率对比
30. Java IO与NIO
31. 反射的作用与原理
32. 泛型常用特点：List&lt;String&gt;能否转为List&lt;Object&gt;
33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL
34. Java与C++对比
35. Java 1.7与1.8新特性
36. 设计模式：单例、工厂、适配器、责任链、观察者等等
37. JNI的使用
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[求职]]></title>
    <link href="http://ranchu90.github.io/14747925084160.html"/>
    <updated>2016-09-25T16:35:08+08:00</updated>
    <id>http://ranchu90.github.io/14747925084160.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>9月开始到现在，陆陆续续也面了5、6个公司，现在暂时告一个段落。<br/>
每家公司面试的风格都不一样，根据面试官问的问题可以分为以下几类：</p>
</blockquote>

<h2 id="toc_0">面试</h2>

<p>现在对过去的几次面试做个总结，每家公司面试的风格都不一样，根据面试官问的问题可以分为以下几类：</p>

<ul>
<li>1.智力类。这类公司喜欢问智力题，比如10个人互相有握手，那么他们总共握了几次手？一个凸多边形的外接矩阵怎么求？等等，从头到尾都是。</li>
<li>2.代码类。直接上来就给题目让写代码。leet code上的题目。</li>
<li>3.工程类。主要关注的点在你做的项目上，使用了什么技术，怎么实现的，还有没有其它的实现方式，这样做有什么缺陷，等等。</li>
<li>4.基础类。对编程语言方面问的很深入，比如JVM模型，GC机制，GC算法，分配过程等等。</li>
<li>5.常规问题。怎么学习的？对未来有什么规划？你还有什么要问我的？</li>
</ul>

<h2 id="toc_1">笔试</h2>

<p>笔试题依据类型可以分为以下几类：</p>

<ul>
<li>1.智力题。特别是BAT，选择题基本上都是智力题。这方面只能靠平时的积累和总结了。</li>
<li>2.基础题。在试卷中有出现，占比根据不同的公司来决定，有些的比例远不如智力题。</li>
<li>3.编程题。几乎是重中之重。最爱考的是字符串处理及动态规划问题。</li>
<li>4.应用题。这类题实际上也是在变相地考察基础，但是比单纯直接地考察基础的要求要高的多。阿里最后一个题是让设计实现一个HotSpot虚拟机。当时我就？？？也有让直接设计一个数据库的题型。</li>
</ul>

<h2 id="toc_2">总结</h2>

<p>准备了很多，但仍然不够充分，每次面试总有答不上来的题。那些题实际上也不是很难，而是没有听说过和接触过。这也是这么多面试的一次收获，我还有那么多需要知道的东西。</p>

<p>这个过程中，对于JAVA基础，JVM内存管理方面的内容我有做一个笔记总结，放在word文档中。这几天会陆陆续续整理后放上来。一来是这段时间学习的总结以便以后在复习的时候可以快速定位不牢固的知识，二来希望我的总结对别人也能有帮助。</p>

<p>对于动态规划的思想还需要更多的练习，简单的可以，复杂一点总是让我花很多时间，最后还总不能全部AC，总是差那么一点。</p>

<p>感谢网络上积极分享知识心得的朋友。我现在准备好好睡一觉。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发基础（二）]]></title>
    <link href="http://ranchu90.github.io/14648586354104.html"/>
    <updated>2016-06-02T17:10:35+08:00</updated>
    <id>http://ranchu90.github.io/14648586354104.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ViewController</h2>

<p>作为连接视图View和模型Model的桥梁(控制器Controller)，从名字就可以看得出来，它是用来管理View的。除此之外，它还承担着传递数据，相应用户操作，内存管理，状态保持和适应设备的功能。</p>

<p>先来看看它的生存周期：<br/>
<img src="media/14648586354104/14648590059763.jpg" alt=""/><br/>
当一个viewController它管理的view出现或者消失的时候会引发相应的方法，如果有需求，可以在对应的方法里写代码来处理相应的事务。</p>

<p>默认状态下，Xcode会将与ViewController同名的Xib文件关联到对应的Controller上。如MyViewController关联到MyView.xib或者MyViewCon.xib。</p>

<p>除此之外也可以用代码来制定加载制定的xib：<br/>
<code><br/>
[UIViewController initWithNibName:@&quot;MyView&quot;];<br/>
</code></p>

<p>或者在IB中指定ViewController，如下：<br/>
<img src="media/14648586354104/14648600281167.jpg" alt=""/></p>

<h3 id="toc_1">跳转</h3>

<p>在viewcontroller中可以跳转到另一个viewcontoller：<br/>
<code><br/>
[self presentViewController: animated: completion:];<br/>
[self showViewController: sender:];<br/>
</code><br/>
撤销当前的view可以使用：<br/>
<code><br/>
[self dismissViewControllerAnimated: completion:];<br/>
</code></p>

<h3 id="toc_2">回传数据</h3>

<p>在其中可以设定回传数据或者在撤销当前view之后执行一段代码。completion是一个代码块block。<br/>
实际上是使用了观察者模式来通知第一个view，并将数据传给它。</p>

<pre><code>//在第二个view中，发送do发生变化的消息，并且将数据存在字典中回转给第一个view
[self dismissViewControllerAnimated:YES completion:^{
        NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;, @&quot;key1&quot;, @&quot;value2&quot;, @&quot;key2&quot;, nil];
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;do&quot; object:self userInfo:dict];
    }];

//在第一个view中的viewDidLoad方法中
//注册观察者，如果do对象有变化就执行Test方法
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(Test:) name:@&quot;do&quot; object:nil];

- (void)Test:(id)sender{
    NSLog(@&quot;%@&quot;, sender);
}

</code></pre>

<p>执行结果：</p>

<pre><code>2016-06-02 17:52:33.594 NibVC[37096:5919151] NSConcreteNotification 0x7fd6495118e0 {name = do; object = &lt;SecondViewController: 0x7fd6494b82d0&gt;; userInfo = {
    key1 = value1;
    key2 = value2;
}

</code></pre>

<p>这种方法不仅可以用于viewController的回传值，还可以用于各个对象之间的消息传递，只需要注册观察者，和发送消息即可。</p>

<h2 id="toc_3">Storyboard</h2>

<p>Storyboard中文译为故事版，也就是做界面的地方，app的应用逻辑和导演讲故事是不是很像呢？在这之前，苹果使用的是xib文件来做的界面。storyboard的有点在于对多个view的管理比xib的要好。</p>

<p>大多数操作就是托控件到view上，如果要关联到.m文件中则要按住Ctrl键+上控件拖到对应的.m文件上即可选择是添加为属性IBOutlet还是方法IBAction。</p>

<h3 id="toc_4">场景的跳转</h3>

<p>Storyboard的场景跳转使用的是Segue，按下Ctrl拖住一个按钮到下一个场景上即可实现。<br/>
可以对Segue进行命名，以便在代码中使用Segue。<br/>
<code><br/>
[self performSegueWithIdentifier:@&quot;&quot; sender:sender];<br/>
</code><br/>
也可以在代码中显示Storyboard里的View Controller：<br/>
<code><br/>
id vc = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;&quot;];<br/>
[self showViewController:vc sender:sender];<br/>
</code></p>

<h3 id="toc_5">返回</h3>

<p>在对应的vc中添加，再在Storyboard中将按钮的方法设置为以下方法。ForSegue可以改变为其它的名字。<br/>
```<br/>
- (void)unwindForSegue:(UIStoryboardSegue*)unwindSegue{</p>

<p>}<br/>
```</p>

<h2 id="toc_6">App的声明周期</h2>

<p><img src="media/14648586354104/14648697010376.jpg" alt=""/></p>

<p><img src="media/14648586354104/14648697197812.jpg" alt=""/></p>

<p><img src="media/14648586354104/14648697311911.jpg" alt=""/></p>

<h2 id="toc_7">Navigation Controller</h2>

<p>NavigationController是一种高效管理多个界面的工具，它可以提供在多个view之间方面地跳转。<br/>
<img src="media/14648586354104/14648707096843.jpg" alt=""/></p>

<p>每个被管理的ViewController自己提供：<br/>
内容，导航栏标题，导航栏上的自定义按钮，或者可选的工具栏按钮。</p>

<p>数据的传递可以通过Segue或者Delegate，Segue上面提到过，下面就列出使用Delegate的方法：<br/>
<code><br/>
- (void)navigationController: willShowViewController: animated:<br/>
- (void)nagivationController: didShowViewController: animated:<br/>
</code></p>

<p>代码中使用</p>

<pre><code>//创建
- initWithRootViewController:
- initWithNavigationBarClass:toolbarClass:
//跳转
- pushViewController:animated:
- popViewControllerAnimated:
- popToRootViewControllerAnimated:
- popToViewController:animated:
</code></pre>

<h2 id="toc_8">Tabbar Controller</h2>

<p><img src="media/14648586354104/14648725794206.jpg" alt=""/><br/>
TabbarController是另一种管理多个ViewController的方式。<br/>
使用方法和NavigationController非常相似。还可以和它结合起来一起使用。</p>

<p><img src="media/14648586354104/14648735896274.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发基础（一）]]></title>
    <link href="http://ranchu90.github.io/14645437888084.html"/>
    <updated>2016-05-30T01:43:08+08:00</updated>
    <id>http://ranchu90.github.io/14645437888084.html</id>
    <content type="html"><![CDATA[
<p>iOS的应用程序是运行在沙盒中的，也就是说各个应用无法访问除自己外的其它应用的地址。<br/>
接下来，我将对iOS开发中常用的组件NSButton，NSImage，NSLabel做一个总结。<br/>
Xcode提供了Interface Builder来方便快速地创建应用界面。<br/>
<img src="media/14645437888084/14645440555938.jpg" alt=""/><br/>
我们可以将想要的控件从这里拖到view上，完成添加。<br/>
通过Outlet插座，按住Ctrl+控件拖拽到对应的ViewController的.h文件中可以将IB中的组件添加到代码里，方便代码的操作。包括添加属性(IBOutlet)和相应方法(IBAction)。<br/>
<img src="media/14645437888084/14645442657409.jpg" alt=""/></p>

<h2 id="toc_0">通过代码添加控件</h2>

<p>把控件加入页面view[self.view addSubview:(UIView)]<br/>
    1   这个方法会retain一次view，并且设置它的下一个响应者是receiver，即它的新的父视图。<br/>
    2   每一个视图只能有唯一的一个父视图。如果当前操作视图已经有另外的一个父视图，则addsubview的操作会把它先从上一个父视图中移除（包括响应者链），再加到新的父视图上面。</p>

<h2 id="toc_1">UILabel</h2>

<pre><code>1   建立UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(x, y, width, height)]; 
2   
3   常用属性 //设置显示文字     
4   label.text = @&quot;label1&quot;;
5   //设置字体:粗体，正常的是 SystemFontOfSize     
6   label.font = [UIFont boldSystemFontOfSize:20];     
7   //设置文字颜色  
8   label.textColor = [UIColor orangeColor];   
9   //设置文字排版方式     
10  label.textAlignment = UITextAlignmentRight;     
11  label.textAlignment = UITextAlignmentCenter;     
12  //设置字体大小适应label宽度     
13  label.adjustsFontSizeToFitWidth = YES;
14  //设置label的显示行数  
15  label.numberOfLines = 2; 
16  //背景色，也可以设置背景图   
17  label.backgroundColor=[UIColor clearColor]; //可以去掉背景色   
18  //设置高亮     
19  label.highlighted = YES;     
20  label.highlightedTextColor = [UIColor orangeColor];     
21  //设置阴影     
22  label.shadowColor = [UIColor redColor];     
23  label.shadowOffset = CGSizeMake(1.0,1.0);     
24  //设置是否能与用户进行交互     
25  label.userInteractionEnabled = YES;     
26  //设置label中的文字是否可变，默认值是YES     
27  label.enabled = NO;     
28  //设置文字过长时的显示格式     
29  label.lineBreakMode = UILineBreakModeMiddleTruncation;//截去中间     
30  //  typedef enum {     
31  //      UILineBreakModeWordWrap = 0,     
32  //      UILineBreakModeCharacterWrap,     
33  //      UILineBreakModeClip,//截去多余部分     
34  //      UILineBreakModeHeadTruncation,//截去头部     
35  //      UILineBreakModeTailTruncation,//截去尾部     
36  //      UILineBreakModeMiddleTruncation,//截去中间     
37  //  } UILineBreakMode;     
38  
</code></pre>

<h2 id="toc_2">UIButton</h2>

<pre><code>1   建立 //UIButton的定义
2   UIButton *button=[[UIButton buttonWithType:(UIButtonType);
3   //typedef enum {
4   //  UIButtonTypeCustom = 0, 自定义风格
5   //  UIButtonTypeRoundedRect, 圆角矩形
6   //  UIButtonTypeDetailDisclosure, 蓝色小箭头按钮，主要做详细说明用
7   //  UIButtonTypeInfoLight, 亮色感叹号
8   //  UIButtonTypeInfoDark, 暗色感叹号
9   //  UIButtonTypeContactAdd, 十字加号按钮
10  //} UIButtonType;
11  
12  常用方法//设置frame
13  button.frame = CGRectMake(20, 20, 280, 40);
14  [button setFrame:CGRectMake(20,20,50,50)];
15  
16  //button背景色
17  button.backgroundColor = [UIColor clearColor];
18  [button setBackgroundColor:[UIColor blueColor]];
19  
20  //是否可点击，默认为YES
21  button.enable = NO;                          
22  //设置button填充图片和背景图片
23  [button setImage:(UIImage) forState:UIControlStateNormal];
24  [button setBackgroundImage:(UIImage)forState:UIControlStateNormal];
25  //设置button标题和标题颜色
26  [button1 setTitle:@&quot;点击&quot; forState:UIControlStateNormal];
27  [button setTitleColor:[UIColor redColor] forState:UIControlStateNormal];
28  
29  //添加或删除事件处理
30  [button addTarget:self action:@selector(butClick:)forControlEvents:UIControlEventTouchUpInside];
31  [button removeTarget:nil action:nil forControlEvents:UIControlEventTouchUpInside];
32  
</code></pre>

<h2 id="toc_3">UIImageView</h2>

<pre><code>1   建立UIImageView *imageView = [[UIImageView alloc ] init];
2   //UIImage加载有两种方式
3   //方案1
4   UIImage *image = [UIImage imageNamed:@&quot;image_photo&quot;];
5   //方案2
6   NSString *filePath=[[NSBundle mainBundle] pathForResource:@&quot;image_photo&quot; ofType:@&quot;jpg&quot;];
7   UIImage *image=[UIImage imageWithContentsOfFile:filePath];
8   
9   imageView.image = image;
10   
</code></pre>

<p>方案一：用imageNamed的方式加载时，系统会把图像Cache到内存。如果图像比较大，或者图像比较多，用这种方式会消耗很大的内存，而且释放图像的内存是一件相对来说比较麻烦的事情。例如：如果利用imageNamed的方式加载图像到一个动态数组NSMutableArray，然后将将数组赋予一个UIView的对象的animationImages进行逐帧动画，那么这将会很有可能造成内存泄露。并且释放图像所占据的内存也不会那么简单。但是利用imageNamed加载图像也有自己的优势。对于同一个图像系统只会把它Cache到内存一次，这对于图像的重复利用是非常有优势的。例如：你需要在一个TableView里重复加载同样一个图标，那么用imageNamed加载图像，系统会把那个图标Cache到内存，在Table里每次利用那个图像的时候，只会把图片指针指向同一块内存。这种情况使用imageNamed加载图像就会变得非常有效。方案二：就是每次单独加载图片，系统不缓存。使用完后记得释放。</p>

<pre><code>1   常用方法 //设置圆角
2   imageView.layer.masksToBounds = YES;
3   imageView.layer.cornerRadius = 10;
4   
5   //设置边框颜色和大小
6   imageView.layer.borderColor = [UIColor orangeColor].CGColor;
7   imageView.layer.borderWidth = 2;
8   
9   //播放一系列图片
10  UIImage *image1 = [UIImage imageNamed:@&quot;1&quot;];
11  UIImage *image2 = [UIImage imageNamed:@&quot;2&quot;];
12  UIImage *image3 = [UIImage imageNamed:@&quot;3&quot;];
13  NSArray *imagesArray = @[image1,image2,image3];
14  imageView.animationImages = imagesArray;
15  // 设定所有的图片在多少秒内播放完毕
16  imageView.animationDuration = [imagesArray count];
17  // 重复播放多少遍，0表示无数遍
18  imageView.animationRepeatCount = 0;
19  // 开始播放
20  [imageView startAnimating];
21  
22   //为图片添加单击事件：一定要先将userInteractionEnabled置为YES，这样才能响应单击事件
23  imageView.userInteractionEnabled = YES;
24  UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapImageView:)];
25  [imageView addGestureRecognizer:singleTap];
26  
27  //其他设置
28  imageView.hidden = YES或者NO;    // 隐藏或者显示图片
29  imageView.alpha =0.5;    // 设置透明度
30  // 设置高亮时显示的图片
31  imageView.highlightedImage = (UIImage *)hightlightedImage;
32  imageView.image = (UIImage *)image; // 设置正常显示的图片
</code></pre>

<h2 id="toc_4">UITextField</h2>

<pre><code>1   建立UITextField* textField = [[UITextField alloc] initWithFrame:CGRectMake(x, y, width, height)];
2   
3   常用方法textField setBorderStyle:UITextBorderStyleRoundedRect]; //外框类型
4   textField.placeholder = @&quot;password&quot;; //默认显示的字 
5   textField.secureTextEntry = YES; //密码 
6   
7   textField.autocorrectionType = UITextAutocorrectionType; //设置是否自动纠错
8   typedef enum {
9       UITextAutocorrectionTypeDefault, //默认
10      UITextAutocorrectionTypeNo, 　//不自动纠错
11      UITextAutocorrectionTypeYes,　//自动纠错
12  }UITextAutocorrectionType;
13  
14  textField.clearButtonMode = UITextFieldViewMode; //编辑时会出现个修改X
15  typedef enum {
16      UITextFieldViewModeNever,　//重不出现
17      UITextFieldViewModeWhileEditing, //编辑时出现
18      UITextFieldViewModeUnlessEditing,　//除了编辑外都出现
19      UITextFieldViewModeAlways 　//一直出现
20  }UITextFieldViewMode; 
21  
22  //可以在UITextField使用下面方法，按return键返回
23  -(IBAction) textFieldDone:(id) sender
24  {
25   [textFieldName resignFirstResponder]; 
26  }
27  //链接TextField控件的&quot;Did end on exit&quot;
28  
29  //再次编辑就清空
30  textField.clearsOnBeginEditing = YES; 
31  
32  //设置键盘样式
33  textField.keyboardType = UIKeyboardType;
34  typedef enum {
35          UIKeyboardTypeDefault,     　//默认键盘，支持所有字符         
36          UIKeyboardTypeASCIICapable,　//支持ASCII的默认键盘
37          UIKeyboardTypeNumbersAndPunctuation,　//标准电话键盘，支持＋＊＃字符
38          UIKeyboardTypeURL,            //URL键盘，支持.com按钮 只支持URL字符
39          UIKeyboardTypeNumberPad,       //数字键盘
40          UIKeyboardTypePhonePad,　 　//电话键盘
41          UIKeyboardTypeNamePhonePad, 　//电话键盘，也支持输入人名
42          UIKeyboardTypeEmailAddress, 　//用于输入电子邮件地址的键盘     
43          UIKeyboardTypeDecimalPad,   　//数字键盘有数字和小数点
44          UIKeyboardTypeTwitter,      　//优化的键盘，方便输入@、#字符
45          UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable, 
46  }UIKeyboardType;
47  
48  //return键样式
49  text.returnKeyType =UIReturnKeyType;
50  typedef enum {
51      UIReturnKeyDefault, 默认 灰色按钮，标有Return
52      UIReturnKeyGo,    　标有Go的蓝色按钮
53      UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索
54      UIReturnKeyJoin,标有Join的蓝色按钮
55      UIReturnKeyNext,标有Next的蓝色按钮
56      UIReturnKeyRoute,标有Route的蓝色按钮
57      UIReturnKeySearch,标有Search的蓝色按钮
58      UIReturnKeySend,标有Send的蓝色按钮
59      UIReturnKeyYahoo,标有Yahoo的蓝色按钮
60      UIReturnKeyYahoo,标有Yahoo的蓝色按钮
61      UIReturnKeyEmergencyCall, 紧急呼叫按钮
62  } UIReturnKeyType;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C复习笔记(二)]]></title>
    <link href="http://ranchu90.github.io/14637124055346.html"/>
    <updated>2016-05-20T10:46:45+08:00</updated>
    <id>http://ranchu90.github.io/14637124055346.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ARC机制</h2>

<p>以往的OBJC是通过程序员手动地管理对象的释放。ARC(Automatic Reference Counting)自动引用计数，现在是OBJC的默认内存管理机制，针对堆上的对象，由编译器自动生成操作引用计数的指令(retain,release)来管理对象的释放。</p>

<h3 id="toc_1">管理的对象</h3>

<table>
<thead>
<tr>
<th>受ARC管理</th>
<th>不受ARC管理</th>
</tr>
</thead>

<tbody>
<tr>
<td>OC对象指针</td>
<td>值类型(基本类型，struct)</td>
</tr>
<tr>
<td>Block指针</td>
<td>其他方式分配的资源(c语言的malloc)</td>
</tr>
<tr>
<td>使用_attribute_((NSObject))定义的typedef</td>
<td>非内存资源</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">管理的方式</h3>

<pre><code>//新创建一个引用类型的对象，这个对象的引用计数初始为1；
NSString *name = [[NSString alloc] initWithString:@&quot;Mono&quot;];
//将对象引用赋值给其它变量或者常量，引用计数+1；
NSString *otherName = name;
//或者将将该对象引用赋值给其它对象的属性或实例变量，引用计数+1；
person.name = name;
//将对象传入函数参数，或者返回值，引用计数+1
print(name);//函数结束后，参数或者局部变量离开函数，该对象的引用计数-1；
//将对象加入集合之中，引用计数+1；
[array addObject];

//将变量或者常量,或者属性赋值为nil或者其他值，引用计数-1；
otherName = nil; or otherName = @&quot;Other Name&quot;;
person.name = nil;
//实例变量和属性所在的对象呗释放，该对象引用计数-1；
[person release];
//将对象从集合中移除的时候，该对象的引用计数-1；
[array removeObject:name];

//当该对象的引用计数变为0的时候，内存自动被释放。
</code></pre>

<h2 id="toc_3">自动释放池(Autorelease Pool)</h2>

<p>如果对象频繁的进行释放和分配，那么会造成琐碎的内存管理负担。autorelease可以讲release的调用延迟到自动释放池被释放时。</p>

<p>当自动释放池结束时，所有接受autorelease消息的对象都将被立即释放(对象被发送一条release消息);</p>

<p>AppKit和UIKit框架在处理每一次事件循环迭代时，都会讲其放入一个Autorelease Pool中，大多数情况无须程序员干预。</p>

<h3 id="toc_4">需要手动管理Autorelease Pool的情况</h3>

<p>1.当编写的程序不是基于UI框架，而是命令行程序时。<br/>
2.如果在循环中创建大量临时对象，需要更早地释放，避免临时对象聚集导致内存峰值过大。<br/>
3.在主线程之外创建新的线程，在新线程开始执行处，需要创建自己的Autorelease Pool。<br/>
4.嵌套使用Autorelease Pool的时候。</p>

<h2 id="toc_5">协议 Protocol</h2>

<p>类型的合同约定，只描述外部接口，不提供具体的实现。<br/>
协议中无法包含实例变量，但可以包含以下的成员：<br/>
属性 （本质上是访问器方法，编译器不会合成实例变量）<br/>
实例方法<br/>
类方法<br/>
初始化器，析构器(不常用)</p>

<h3 id="toc_6">使用协议</h3>

<p>1.一个类遵守协议，需实现该协议约定的所有@required的成员，即必须要实现的成员。<br/>
协议中的属性必须在实现类的.h接口文件中声明(编译器合成实例变量)<br/>
2.协议本质上是一种类型，可以作为声明类型，但是不能创建实例。<br/>
3.可以使用conformsToProtocl:检查是否实现了协议。<br/>
4.编译警告：1）未实现必选方法。2）协议类型变量被赋值为非协议类型变量。运行会出错。</p>

<h4 id="toc_7">协议的继承</h4>

<p>一个协议可以继承一个或者多个协议。<br/>
实现子协议的类型，同时也要实现父协议中必须是实现的成员。</p>

<h4 id="toc_8">协议的组合</h4>

<p>一个类可以同时实现多个协议，protocal<A,B,C....>来组合多个协议<br/>
实现组合协议的类型，必须实现组合协议中的每一个协议</p>

<h4 id="toc_9">协议中的可选</h4>

<p>协议中使用关键字@optional定义的成员是可以选择不必实现的。</p>

<h3 id="toc_10">常用的协议</h3>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>NSObject</td>
<td>包含对象的常用操作，相等、字符串表示、哈希。</td>
</tr>
<tr>
<td>NSCopying</td>
<td>支持复制的类型必须遵守该协议。</td>
</tr>
<tr>
<td>NSMutableCopying</td>
<td>在NSCopying协议的基础上，支持复制数据的可变性。</td>
</tr>
<tr>
<td>NSFastEnumeration</td>
<td>实现快速枚举for-in的类型采用</td>
</tr>
<tr>
<td>NSCoding</td>
<td>支持将对象图进行编码或解码以支持对象的序列化</td>
</tr>
</tbody>
</table>

<h2 id="toc_11">类别 Categroy</h2>

<p>在没有源代码的情况下，基于某些场合的需要，为一个类增加功能。<br/>
可增加 | 不可增加<br/>
--------- | -------------<br/>
类方法 | 属性<br/>
实例方法| 实例变量<br/>
重写父类方法 | 已存在的同名方法</p>

<h3 id="toc_12">命名规范</h3>

<p>文件名：类名+扩展方法，如：Person+Sport.h/m</p>

<h3 id="toc_13">类别的使用</h3>

<h4 id="toc_14">场景</h4>

<p>1.适合在没有源代码的情况下，想已经封装的类中添加方法。<br/>
2.为一个类在某些特殊场景下增加功能。<br/>
3.对于复杂的大型文件分割实现。<br/>
4.可以通过类别重写现有方法，但一般不推荐，这样会导致无法调用被扩展的类的初始方法，只能访问重写过的方法。</p>

<h4 id="toc_15">添加类别的对象</h4>

<p>1.自己创建的类。<br/>
2.系统的类。<br/>
3.第三方库。</p>

<h4 id="toc_16">类别限制</h4>

<p>1.类别不能在扩展类中添加任何成员变量。<br/>
2.重写现有方法时，无法调用原始现有对象方法。<br/>
3.若两个类别都定义了一个相同类的相同方法，运行时实际无法确定调用哪一个。</p>

<h2 id="toc_17">扩展 Extension</h2>

<p>扩展支持在编译时，在有类的源代码的前提下，向类添加功能。可看做是匿名的类别。</p>

<p>接口在.m文件中的@implementation前声明，实现代码在@implementation 内实现。</p>

<p>扩展支持添加以下成员：<br/>
1.属性。<br/>
2.实例成员。<br/>
3.类方法。<br/>
4.实例方法。<br/>
5.改写属性的读写属性。</p>

<h3 id="toc_18">扩展的使用</h3>

<p>扩展实现的成员只能在。m文件内部访问，类外无法直接往访问。</p>

<p>扩展的主要用途在于信息隐藏，隐藏一些外部无须访问、而内部实现又需要使用的属性、方法：<br/>
1.类的主要接口用于“对类以外公开”<br/>
2.类的扩展接口用于“对类内可见”</p>

]]></content>
  </entry>
  
</feed>
