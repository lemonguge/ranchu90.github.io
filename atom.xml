<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[cd's blog]]></title>
  <link href="http://ranchu90.github.io/atom.xml" rel="self"/>
  <link href="http://ranchu90.github.io/"/>
  <updated>2016-09-27T16:13:38+08:00</updated>
  <id>http://ranchu90.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[14. try catch finally，try里有return，finally还执行么]]></title>
    <link href="http://ranchu90.github.io/14750561415107.html"/>
    <updated>2016-09-28T17:49:01+08:00</updated>
    <id>http://ranchu90.github.io/14750561415107.html</id>
    <content type="html"><![CDATA[
<p>finally中的内容一定会执行的</p>

<pre><code>try{
    return 0;
} catch(Exception e){
    return 1;
} finally{
    return 2;
}
</code></pre>

<p>finally中的return会覆盖try，catch中的return，所以最后返回的是finally中的值</p>

<pre><code>class Main{
    public static String lem(){
        System.out.println(&quot;lem&quot;);
        return &quot;return from lem&quot;;
    }
    
    public static String foo(){
        int x = 0;
        int y = 5;
        try {
            System.out.println(&quot;start try&quot;);
            int b = y/x;
            System.out.println(&quot;end try&quot;);
            return &quot;return from try&quot;;
        } catch (Exception e) {
            System.out.println(&quot;catch&quot;);
            return lem() + &quot;| return from catch&quot;;
        } finally {
            System.out.println(&quot;finally&quot;);
            return &quot;return from finally&quot;;
        }
    }
    
    public static void main(String[] args) {
        String v = foo();
        
        System.out.println(v);
    }
}
</code></pre>

<p>输出：</p>

<pre><code>start try
catch
lem
finally
return from finally
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[12. TreeMap、HashMap、LinkedHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14750544918726.html"/>
    <updated>2016-09-28T17:21:31+08:00</updated>
    <id>http://ranchu90.github.io/14750544918726.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>TreeMap</th>
<th>LinkedHashMap</th>
</tr>
</thead>

<tbody>
<tr>
<td>遍历顺序</td>
<td>随机</td>
<td>实现了sortMap接口，按自然顺序或自定义顺序</td>
<td>与输入顺序相同</td>
</tr>
</tbody>
</table>

<p>weakHashMap与HashMap类似，它从用若引用，其中key不再被外部引用时即被JVM回收，HashMap采用强引用，key不被外部引用时，必须从Map中删除才能被GC回收</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[11. HashMap、Hashtable、ConcurrentHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14749678612341.html"/>
    <updated>2016-09-27T17:17:41+08:00</updated>
    <id>http://ranchu90.github.io/14749678612341.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">多线程下的HashMap</h2>

<p>HashMap是线程不安全的，在多线程环境中并发操作会存在以下问题：</p>

<ul>
<li>  多线程使用put()，触发resize(rehash)操作，创建多个newTable，再同时rehash，导致链表错乱。这时候，再使用get()操作将进入无线循环。getEntry获取table中的链表，链表成了一个循环链表，所以进入无线循环。</li>
</ul>

<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>

<ul>
<li>remove()，遍历map时调用remove，可能会导致丢失删除的数据后面的数据，跳到下一个槽位。</li>
</ul>

<h2 id="toc_1">ConcurrentHashMap和Hashtable</h2>

<p>concurrent,同时发生的。同时发生的hashmap，从名字就可以知道它专门用于多线程的情况。<br/>
它不同于hashtable，hashtable在方法前使用synchronized来保证同步这会导致被当一个对象被锁住的时候，另一个线程无法使用get()方法，而ConcurrentHashMap对map进行分段，在插入时使用段（继承自重用锁），来实现线程之间的同步。<br/>
但是在最新的java源码里我看到的是在put方法中使用synchronized块来实现同步。</p>

<pre><code> /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
</code></pre>

<p>以下三篇文章中有详细的说明可以参考下</p>

<p><a href="http://ifeve.com/concurrenthashmap/">http://ifeve.com/concurrenthashmap/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-1/">http://ifeve.com/java-concurrent-hashmap-1/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-2/">http://ifeve.com/java-concurrent-hashmap-2/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10. HashMap和HashTable的区别]]></title>
    <link href="http://ranchu90.github.io/14749657860314.html"/>
    <updated>2016-09-27T16:43:06+08:00</updated>
    <id>http://ranchu90.github.io/14749657860314.html</id>
    <content type="html"><![CDATA[
<p>Map<br/>
├Hashtable<br/>
├HashMap<br/>
└WeakHashMap</p>

<p>HashMap和HashTable都是Java中哈希表的实现方式。其中HashTable里的大多数方法比如add、remove..等前有synchronized修饰，所以它在多线程的环境下是线程安全的，也因此需要耗费性能在同步的问题上。而HashMap不是，所以它的效率较HashTable高。<br/>
HashMap中可以使用null作为key，这在HashTable中是不允许的。<br/>
HashMap中的contains方法因为语义不明改为containsKey()和containsValue()。<br/>
(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>

<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>

<tbody>
<tr>
<td>null作为key</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>contains()</td>
<td>改为containsKey() constainsValue()</td>
<td>继承Dicitionary</td>
</tr>
<tr>
<td>线程安全</td>
<td>否 效率较高</td>
<td>是 效率较低</td>
</tr>
<tr>
<td>迭代</td>
<td>iterator</td>
<td>enumeration</td>
</tr>
<tr>
<td>hash性能</td>
<td>几乎一样 使用hashcode()方法</td>
<td></td>
</tr>
<tr>
<td>hash值</td>
<td>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</td>
<td>直接hashcode方法的值</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9. Map、Set、List、Queue、Stack的特点与用法]]></title>
    <link href="http://ranchu90.github.io/14749474920939.html"/>
    <updated>2016-09-27T11:38:12+08:00</updated>
    <id>http://ranchu90.github.io/14749474920939.html</id>
    <content type="html"><![CDATA[
<p>Collections框架中包含了大量的集合接口及这些接口的实现。主要提供了9种Map、Set、List、Queue、Stack等数据结构。</p>

<ul>
<li>Set接口表示数学中集合的概念。其主要特点是集合中的元素不重复。</li>
<li>List接口表示有序的集合。它按照对象进入的顺序保存对象，所以能对每个元素的插入和删除具体的位置进行精确的控制。它能存放重复的对象。</li>
<li>Map接口提供了一个从Key到Value的数据结构，保存键值对。其中Value可以重复，但是Key不能重复。</li>
<li>Queue接口提供了“先进先出”队列的数据结构。只能在队尾添加元素，只能在对头弹出元素。</li>
<li>Stack继承自Vector，它实现了先进后出的栈结构。</li>
</ul>

<p>我在网络上找到一张实现Collection接口的类图，可以一目了然地看到实现的类及他们之间的关系。<br/>
<img src="media/14749474920939/14749600076300.jpg" alt=""/></p>

<p>Collection接口定义了一套统一的操作方法：</p>

<pre><code>int size();
返回容器中元素的个数
boolean isEmpty();
判断容器是否为空，空则返回true，否则false
boolean contains(Object o);
判段容器是否包含o对象
Iterator&lt;E&gt; iterator();
获得该容器的迭代器
Object[] toArray();
将容器转换为对象数组
boolean add(E e);
向容器中添加元素
boolean remove(Object o);
移除容器中的对象
boolean containsAll(Collection&lt;?&gt; c);
判断是否包含c中的所有元素
boolean addAll(Collection&lt;? extends E&gt; c);
添加c容器中的所有元素
boolean removeAll(Collection&lt;?&gt; c);
移除c中包含的所有元素
boolean retainAll(Collection&lt;?&gt; c);
保留c中存在的元素，移除c中不存在的元素
void clear();
清除容器中的所有元素
</code></pre>

<p>Stack类中除了继承了Vector的方法外还实现了</p>

<pre><code>boolean empty() 
测试堆栈是否为空。
Object peek( )
查看堆栈顶部的对象，但不从堆栈中移除它。
Object pop( )
移除堆栈顶部的对象，并作为此函数的值返回该对象。
Object push(Object element)
把项压入堆栈顶部。
int search(Object element)
返回对象在堆栈中的位置，以 1 为基数。
</code></pre>

<p>Queue类中常用方法</p>

<pre><code>boolean add(E e);        
增加一个元素              若队列已满，则抛出一个IIIegaISlabEepeplian异常
boolean remove();   
移除并返回队列头部的元素    若队列为空，则抛出一个NoSuchElementException异常
E element()  
返回队列头部的元素         若队列为空，则抛出一个NoSuchElementException异常
offer(E e)      
添加一个元素并返回true     若队列已满，则返回false
E poll()      
移除并返问队列头部的元素    若队列为空，则返回null
E peek()     
返回队列头部的元素         若队列为空，则返回null
void put()     
添加一个元素              若队列满，则阻塞
void take()
移除并返回队列头部的元素    若队列为空，则阻塞
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[8. String、StringBuffer与StringBuilder的区别]]></title>
    <link href="http://ranchu90.github.io/14749467173553.html"/>
    <updated>2016-09-27T11:25:17+08:00</updated>
    <id>http://ranchu90.github.io/14749467173553.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>

<tbody>
<tr>
<td>可变性</td>
<td>不可变类</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td>线程安全</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>适用场合</td>
<td>被共享的场合 少量数据</td>
<td>经常修改的场合 避免附加操作 无用对象 提高效率 多线程大量数据</td>
<td>单线程下大量数据</td>
</tr>
<tr>
<td>构建</td>
<td>构造函数 ==赋值</td>
<td>构造函数</td>
<td>构造函数</td>
</tr>
<tr>
<td>执行效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7. ArrayList、LinkedList、Vector的区别]]></title>
    <link href="http://ranchu90.github.io/14748992011687.html"/>
    <updated>2016-09-26T22:13:21+08:00</updated>
    <id>http://ranchu90.github.io/14748992011687.html</id>
    <content type="html"><![CDATA[
<p>Collection包结构，Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法。实现该接口的类主要有List和Set，其目的在于为各种具体的集合提供最大化的统一的操作方式。<br/>
Collection包结构</p>

<pre><code>Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set
</code></pre>

<p>ArrayList和Vector是顺序存储（物理上连续的内存空间）的集合，使用的时候可以根据下标进行访问，索引数据的效率高。但是在删除或者插入时，需要移动容器中的元素，因此插入删除时，效率低。<br/>
另外，Vector的大多数方法前都有synchronized关键字，因此是线程安全的，ArrayList则不是。</p>

<p>容量扩充：当ArrayList或Vector中设定的容量不够容纳新的节点时，会自动调用grow()方法进行容量的扩充。ArrayList默认扩充原来大小的1.5倍。Vector默认扩充原来大小的2倍，指定capacityIncrement的话，每次扩充指定的大小。</p>

<pre><code>//ArrayList
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
//LinkedList
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
</code></pre>

<p>LinkedList采用双向链表实现，无法使用下标访问。每次由下标获取元素的时候，先判断其在前半段还是后半段，在前半段从头结点开始查找，在后半段从尾节点从后往前查找。因此，查找时，效率较ArrayList和Vector低。但是插入或者删除操作，只需要进行节点的删除或者连接操作，因此效率较前二者高。</p>

<pre><code>Node&lt;E&gt; node(int index) {
        // assert isElementIndex(index);

        if (index &lt; (size &gt;&gt; 1)) {
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6. Hashcode的作用]]></title>
    <link href="http://ranchu90.github.io/14748977980780.html"/>
    <updated>2016-09-26T21:49:58+08:00</updated>
    <id>http://ranchu90.github.io/14748977980780.html</id>
    <content type="html"><![CDATA[
<p>1.在HashMap、HashTable..等集合类中，采用邻接矩阵的数据结构实现，hashCode()值用来散列存储结构中确定对象的存储地址。</p>

<p>2.找到目标地址后，在链表的遍历中使用equals()方法判断两个对象的内容是否相同。</p>

<p>3.如果equals()被重写，那么该对象的hashCode()也要被重写，以保证2中的条件成立。</p>

<p>4.由邻接矩阵的结构可知，hashCode值相同的对象，其内容不一定相同，只能说明他们存放在同一条链表中。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5. Java的四种引用，强弱软虚，用到的场景]]></title>
    <link href="http://ranchu90.github.io/14748971773098.html"/>
    <updated>2016-09-26T21:39:37+08:00</updated>
    <id>http://ranchu90.github.io/14748971773098.html</id>
    <content type="html"><![CDATA[
<p>Java对对象的引用分为四种：<br/>
1.强引用。强引用的对象不会被垃圾回收器回收。内存不足时，宁可抛出OOM错误也不会回收强引用。</p>

<p>2.软引用。可有可无的引用，当JVM内存足够的时候不会被回收；当JVM内存不足的时候，发现软引用的存在，会回收软引用。</p>

<p>3.若引用。可有可无的引用，一旦被垃圾回收器发现，马上就被其回收。</p>

<p>4.幽灵引用。它一般用来标记被回收的对象，当对象被回收后，会受到一条消息。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4.Object有哪些公用方法？]]></title>
    <link href="http://ranchu90.github.io/14748970236814.html"/>
    <updated>2016-09-26T21:37:03+08:00</updated>
    <id>http://ranchu90.github.io/14748970236814.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1．clone方法</h2>

<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>

<h2 id="toc_1">2．getClass方法</h2>

<p>final方法，获得运行时类型。</p>

<h2 id="toc_2">3．toString方法</h2>

<p>该方法用得比较多，一般子类都有覆盖。</p>

<h2 id="toc_3">4．finalize方法</h2>

<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。自动垃圾收集 器 会 调用 finalize() 方法。</p>

<h2 id="toc_4">5．equals方法</h2>

<p>该方法是非常重要的一个方法。一般equals和<code>==</code>是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>

<h2 id="toc_5">6．hashCode方法</h2>

<p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。<br/>
一般必须满足obj1.equals(obj2)<code>==</code>true。可以推出obj1.hashCode()<code>==</code>obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>

<h2 id="toc_6">7．wait方法</h2>

<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br/>
调用该方法后当前线程进入睡眠状态，直到以下事件发生。<br/>
（1）其他线程调用了该对象的notify方法。<br/>
（2）其他线程调用了该对象的notifyAll方法。<br/>
（3）其他线程调用了interrupt中断该线程。<br/>
（4）时间间隔到了。<br/>
此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>

<h2 id="toc_7">8．notify方法</h2>

<p>该方法唤醒在该对象上等待的某个线程。</p>

<h2 id="toc_8">9．notifyAll方法</h2>

<p>该方法唤醒在该对象上等待的所有线程。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3.equals()和==的区别]]></title>
    <link href="http://ranchu90.github.io/14748960344939.html"/>
    <updated>2016-09-26T21:20:34+08:00</updated>
    <id>http://ranchu90.github.io/14748960344939.html</id>
    <content type="html"><![CDATA[
<p><code>==</code>用于判断两边的变量的值是否相等，如果是基本数据类型，就是判断他们的值是不是相等；如果<code>==</code>两边是对象的引用，那么指的是这两个引用是否指向同一个对象，及引用的值是否相等。</p>

<p><code>equals()</code>是Object里的方法。在Object的equals中，就是使用<code>==</code>来进行比较，比较的是引用。与<code>==</code>不同的是，在某些Object的子类中，覆盖了equals()方法，比如String中的equals()方法比较两个字符串对象的内容是否相同。</p>

<p><code>hashCode()</code>方法也是继承自Object，它用来获取一个对象的hash值，返回int值。Object.hashCode规定，equals()相等的对象，它们的HashCode()返回值也必须相等，否则无法与集合类结合在一起使用。(List, Set, Hashmap..)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2.  Switch能否用String做参数？]]></title>
    <link href="http://ranchu90.github.io/14748943230133.html"/>
    <updated>2016-09-26T20:52:03+08:00</updated>
    <id>http://ranchu90.github.io/14748943230133.html</id>
    <content type="html"><![CDATA[
<p>1.jdk1.7之前只能使用int型作为参数，byte、short会自动转换成int进行比较。<br/>
2.在jdk 1.7之前，无法使用String作为参数。1.7以后加入。<br/>
原理：hashCode()+equals()<br/>
编译器在编译期间给代码做了转换。<br/>
原始：</p>

<pre><code>public class StringInSwitchCase { 
      public static void main(String[] args) { 
            String mode = args[0]; 
            switch (mode) { 
                  case &quot;ACTIVE&quot;: 
                        System.out.println(&quot;Application is running on Active mode&quot;); 
                        break; 
                  case &quot;PASSIVE&quot;:
                        System.out.println(&quot;Application is running on Passive mode&quot;); 
                         break; 
                  case &quot;SAFE&quot;: 
                          System.out.println(&quot;Application is running on Safe mode&quot;); 
          } 
      } 
}
</code></pre>

<p>编译器优化后：</p>

<pre><code>import java.io.PrintStream; 
 
public class StringInSwitchCase{ 
      public StringInSwitchCase() { } 
 
      public static void main(string args[]) { 
             String mode = args[0]; 
            String s; switch ((s = mode).hashCode()) { 
                  default: break; 
                  case -74056953: 
                        if (s.equals(&quot;PASSIVE&quot;)) { 
                                    System.out.println(&quot;Application is running on Passive mode&quot;); 
                         } 
                        break; 
                  case 2537357: 
                        if (s.equals(&quot;SAFE&quot;)) { 
                              System.out.println(&quot;Application is running on Safe mode&quot;); 
                         } 
                        break; 
                  case 1925346054: 
                        if (s.equals(&quot;ACTIVE&quot;)) { 
                              System.out.println(&quot;Application is running on Active mode&quot;); 
                         } 
                        break; 
               } 
          } 
}
</code></pre>

<p>参考资料：<br/>
<a href="http://www.importnew.com/14597.html">http://www.importnew.com/14597.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1.	九种基本数据类型的大小，以及他们的封装类]]></title>
    <link href="http://ranchu90.github.io/14748770602290.html"/>
    <updated>2016-09-26T16:04:20+08:00</updated>
    <id>http://ranchu90.github.io/14748770602290.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>包装类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>boolean</td>
<td>32-bit</td>
<td>-</td>
<td>-</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16-bit</td>
<td>Unicode 0</td>
<td>Unicode 2<sup>16</sup> -1</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8-bit</td>
<td>-2<sup>7</sup></td>
<td>2<sup>7</sup> -1</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16-bit</td>
<td>-2<sup>15</sup></td>
<td>2<sup>15</sup> -1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32-bit</td>
<td>-2<sup>31</sup></td>
<td>2<sup>31</sup> -1</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64-bit</td>
<td>-2<sup>63</sup></td>
<td>2<sup>63</sup> -1</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32-bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64-bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody>
</table>

<h2 id="toc_0">使用封装类的目的</h2>

<p>集合类中存放的都是对象，为了使集合类也能存放基本数据类型，Java提供了其对应的包装类。</p>

<h2 id="toc_1">封装类与基本数据类型的区别</h2>

<ol>
<li>传递类型不同，封装类是引用传递，基本数据类型是值传递。</li>
<li>内存分配不同，类在堆上分配，基本类型在Java虚拟栈上分配。</li>
</ol>

<h2 id="toc_2">void类型</h2>

<p>Java编程思想中奖void也纳入基本数据类型。Java文档中对void的解释:</p>

<pre><code>/**
 * The {@code Void} class is an uninstantiable placeholder class to hold a
 * reference to the {@code Class} object representing the Java keyword
 * void.
 *
 * @author  unascribed
 * @since   JDK1.1
 */
</code></pre>

<p>java.lang.Void 类是一个不可实例化的占位符类来保存一个引用代表了Java关键字void的Class对象。Void无法通过new在堆中分配空间。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[J2SE基础问题汇总]]></title>
    <link href="http://ranchu90.github.io/14748751468195.html"/>
    <updated>2016-09-26T15:32:26+08:00</updated>
    <id>http://ranchu90.github.io/14748751468195.html</id>
    <content type="html"><![CDATA[
<pre><code>1.  九种基本数据类型的大小，以及他们的封装类
2.  Switch能否用string做参数？
3. equals()与==的区别
4. Object有哪些公用方法？
5. Java的四种引用，强弱软虚，用到的场景。
6. Hashcode的作用
7. ArrayList、LinkedList、Vector的区别
8. String、StringBuffer与StringBuilder的区别
9. Map、Set、List、Queue、Stack的特点与用法
10. HashMap和HashTable的区别
11. HashMap和ConcurrentHashMap的区别
12. TreeMap、HashMap、LinkedHashMap的区别。
13. Collection包结构，与Collections的区别
14. try catch finally，try里有return，finally还执行么
15. Exception与Error包结构。常见的OOM和SOF。
16. Java面向对象的三个特征与含义
17. Override和Overload的含义去区别
18. Interface与abstract类的区别
19. Static inner class 与non static inner class的区别
20. Java多态的实现原理
21. 实现多线程的两种方法：Thread与Runable
22. 线程同步的方法：synchronized、lock、reentrantLock等
23. 锁的等级：方法锁、对象锁、类锁。
24. 写出生产者消费者模式。
25. ThreadLocal的设计理念与作用。
26. ThreadPool用法与优势。
27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等
28. wait()和sleep()的区别
29. foreach与正常for循环效率对比
30. Java IO与NIO
31. 反射的作用与原理
32. 泛型常用特点：List&lt;String&gt;能否转为List&lt;Object&gt;
33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL
34. Java与C++对比
35. Java 1.7与1.8新特性
36. 设计模式：单例、工厂、适配器、责任链、观察者等等
37. JNI的使用
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[求职]]></title>
    <link href="http://ranchu90.github.io/14747925084160.html"/>
    <updated>2016-09-25T16:35:08+08:00</updated>
    <id>http://ranchu90.github.io/14747925084160.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>9月开始到现在，陆陆续续也面了5、6个公司，现在暂时告一个段落。<br/>
每家公司面试的风格都不一样，根据面试官问的问题可以分为以下几类：</p>
</blockquote>

<h2 id="toc_0">面试</h2>

<p>现在对过去的几次面试做个总结，每家公司面试的风格都不一样，根据面试官问的问题可以分为以下几类：</p>

<ul>
<li>1.智力类。这类公司喜欢问智力题，比如10个人互相有握手，那么他们总共握了几次手？一个凸多边形的外接矩阵怎么求？等等，从头到尾都是。</li>
<li>2.代码类。直接上来就给题目让写代码。leet code上的题目。</li>
<li>3.工程类。主要关注的点在你做的项目上，使用了什么技术，怎么实现的，还有没有其它的实现方式，这样做有什么缺陷，等等。</li>
<li>4.基础类。对编程语言方面问的很深入，比如JVM模型，GC机制，GC算法，分配过程等等。</li>
<li>5.常规问题。怎么学习的？对未来有什么规划？你还有什么要问我的？</li>
</ul>

<h2 id="toc_1">笔试</h2>

<p>笔试题依据类型可以分为以下几类：</p>

<ul>
<li>1.智力题。特别是BAT，选择题基本上都是智力题。这方面只能靠平时的积累和总结了。</li>
<li>2.基础题。在试卷中有出现，占比根据不同的公司来决定，有些的比例远不如智力题。</li>
<li>3.编程题。几乎是重中之重。最爱考的是字符串处理及动态规划问题。</li>
<li>4.应用题。这类题实际上也是在变相地考察基础，但是比单纯直接地考察基础的要求要高的多。阿里最后一个题是让设计实现一个HotSpot虚拟机。当时我就？？？也有让直接设计一个数据库的题型。</li>
</ul>

<h2 id="toc_2">总结</h2>

<p>准备了很多，但仍然不够充分，每次面试总有答不上来的题。那些题实际上也不是很难，而是没有听说过和接触过。这也是这么多面试的一次收获，我还有那么多需要知道的东西。</p>

<p>这个过程中，对于JAVA基础，JVM内存管理方面的内容我有做一个笔记总结，放在word文档中。这几天会陆陆续续整理后放上来。一来是这段时间学习的总结以便以后在复习的时候可以快速定位不牢固的知识，二来希望我的总结对别人也能有帮助。</p>

<p>对于动态规划的思想还需要更多的练习，简单的可以，复杂一点总是让我花很多时间，最后还总不能全部AC，总是差那么一点。</p>

<p>感谢网络上积极分享知识心得的朋友。我现在准备好好睡一觉。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发基础（二）]]></title>
    <link href="http://ranchu90.github.io/14648586354104.html"/>
    <updated>2016-06-02T17:10:35+08:00</updated>
    <id>http://ranchu90.github.io/14648586354104.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ViewController</h2>

<p>作为连接视图View和模型Model的桥梁(控制器Controller)，从名字就可以看得出来，它是用来管理View的。除此之外，它还承担着传递数据，相应用户操作，内存管理，状态保持和适应设备的功能。</p>

<p>先来看看它的生存周期：<br/>
<img src="media/14648586354104/14648590059763.jpg" alt=""/><br/>
当一个viewController它管理的view出现或者消失的时候会引发相应的方法，如果有需求，可以在对应的方法里写代码来处理相应的事务。</p>

<p>默认状态下，Xcode会将与ViewController同名的Xib文件关联到对应的Controller上。如MyViewController关联到MyView.xib或者MyViewCon.xib。</p>

<p>除此之外也可以用代码来制定加载制定的xib：<br/>
<code><br/>
[UIViewController initWithNibName:@&quot;MyView&quot;];<br/>
</code></p>

<p>或者在IB中指定ViewController，如下：<br/>
<img src="media/14648586354104/14648600281167.jpg" alt=""/></p>

<h3 id="toc_1">跳转</h3>

<p>在viewcontroller中可以跳转到另一个viewcontoller：<br/>
<code><br/>
[self presentViewController: animated: completion:];<br/>
[self showViewController: sender:];<br/>
</code><br/>
撤销当前的view可以使用：<br/>
<code><br/>
[self dismissViewControllerAnimated: completion:];<br/>
</code></p>

<h3 id="toc_2">回传数据</h3>

<p>在其中可以设定回传数据或者在撤销当前view之后执行一段代码。completion是一个代码块block。<br/>
实际上是使用了观察者模式来通知第一个view，并将数据传给它。</p>

<pre><code>//在第二个view中，发送do发生变化的消息，并且将数据存在字典中回转给第一个view
[self dismissViewControllerAnimated:YES completion:^{
        NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;, @&quot;key1&quot;, @&quot;value2&quot;, @&quot;key2&quot;, nil];
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;do&quot; object:self userInfo:dict];
    }];

//在第一个view中的viewDidLoad方法中
//注册观察者，如果do对象有变化就执行Test方法
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(Test:) name:@&quot;do&quot; object:nil];

- (void)Test:(id)sender{
    NSLog(@&quot;%@&quot;, sender);
}

</code></pre>

<p>执行结果：</p>

<pre><code>2016-06-02 17:52:33.594 NibVC[37096:5919151] NSConcreteNotification 0x7fd6495118e0 {name = do; object = &lt;SecondViewController: 0x7fd6494b82d0&gt;; userInfo = {
    key1 = value1;
    key2 = value2;
}

</code></pre>

<p>这种方法不仅可以用于viewController的回传值，还可以用于各个对象之间的消息传递，只需要注册观察者，和发送消息即可。</p>

<h2 id="toc_3">Storyboard</h2>

<p>Storyboard中文译为故事版，也就是做界面的地方，app的应用逻辑和导演讲故事是不是很像呢？在这之前，苹果使用的是xib文件来做的界面。storyboard的有点在于对多个view的管理比xib的要好。</p>

<p>大多数操作就是托控件到view上，如果要关联到.m文件中则要按住Ctrl键+上控件拖到对应的.m文件上即可选择是添加为属性IBOutlet还是方法IBAction。</p>

<h3 id="toc_4">场景的跳转</h3>

<p>Storyboard的场景跳转使用的是Segue，按下Ctrl拖住一个按钮到下一个场景上即可实现。<br/>
可以对Segue进行命名，以便在代码中使用Segue。<br/>
<code><br/>
[self performSegueWithIdentifier:@&quot;&quot; sender:sender];<br/>
</code><br/>
也可以在代码中显示Storyboard里的View Controller：<br/>
<code><br/>
id vc = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;&quot;];<br/>
[self showViewController:vc sender:sender];<br/>
</code></p>

<h3 id="toc_5">返回</h3>

<p>在对应的vc中添加，再在Storyboard中将按钮的方法设置为以下方法。ForSegue可以改变为其它的名字。<br/>
```<br/>
- (void)unwindForSegue:(UIStoryboardSegue*)unwindSegue{</p>

<p>}<br/>
```</p>

<h2 id="toc_6">App的声明周期</h2>

<p><img src="media/14648586354104/14648697010376.jpg" alt=""/></p>

<p><img src="media/14648586354104/14648697197812.jpg" alt=""/></p>

<p><img src="media/14648586354104/14648697311911.jpg" alt=""/></p>

<h2 id="toc_7">Navigation Controller</h2>

<p>NavigationController是一种高效管理多个界面的工具，它可以提供在多个view之间方面地跳转。<br/>
<img src="media/14648586354104/14648707096843.jpg" alt=""/></p>

<p>每个被管理的ViewController自己提供：<br/>
内容，导航栏标题，导航栏上的自定义按钮，或者可选的工具栏按钮。</p>

<p>数据的传递可以通过Segue或者Delegate，Segue上面提到过，下面就列出使用Delegate的方法：<br/>
<code><br/>
- (void)navigationController: willShowViewController: animated:<br/>
- (void)nagivationController: didShowViewController: animated:<br/>
</code></p>

<p>代码中使用</p>

<pre><code>//创建
- initWithRootViewController:
- initWithNavigationBarClass:toolbarClass:
//跳转
- pushViewController:animated:
- popViewControllerAnimated:
- popToRootViewControllerAnimated:
- popToViewController:animated:
</code></pre>

<h2 id="toc_8">Tabbar Controller</h2>

<p><img src="media/14648586354104/14648725794206.jpg" alt=""/><br/>
TabbarController是另一种管理多个ViewController的方式。<br/>
使用方法和NavigationController非常相似。还可以和它结合起来一起使用。</p>

<p><img src="media/14648586354104/14648735896274.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发基础（一）]]></title>
    <link href="http://ranchu90.github.io/14645437888084.html"/>
    <updated>2016-05-30T01:43:08+08:00</updated>
    <id>http://ranchu90.github.io/14645437888084.html</id>
    <content type="html"><![CDATA[
<p>iOS的应用程序是运行在沙盒中的，也就是说各个应用无法访问除自己外的其它应用的地址。<br/>
接下来，我将对iOS开发中常用的组件NSButton，NSImage，NSLabel做一个总结。<br/>
Xcode提供了Interface Builder来方便快速地创建应用界面。<br/>
<img src="media/14645437888084/14645440555938.jpg" alt=""/><br/>
我们可以将想要的控件从这里拖到view上，完成添加。<br/>
通过Outlet插座，按住Ctrl+控件拖拽到对应的ViewController的.h文件中可以将IB中的组件添加到代码里，方便代码的操作。包括添加属性(IBOutlet)和相应方法(IBAction)。<br/>
<img src="media/14645437888084/14645442657409.jpg" alt=""/></p>

<h2 id="toc_0">通过代码添加控件</h2>

<p>把控件加入页面view[self.view addSubview:(UIView)]<br/>
    1   这个方法会retain一次view，并且设置它的下一个响应者是receiver，即它的新的父视图。<br/>
    2   每一个视图只能有唯一的一个父视图。如果当前操作视图已经有另外的一个父视图，则addsubview的操作会把它先从上一个父视图中移除（包括响应者链），再加到新的父视图上面。</p>

<h2 id="toc_1">UILabel</h2>

<pre><code>1   建立UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(x, y, width, height)]; 
2   
3   常用属性 //设置显示文字     
4   label.text = @&quot;label1&quot;;
5   //设置字体:粗体，正常的是 SystemFontOfSize     
6   label.font = [UIFont boldSystemFontOfSize:20];     
7   //设置文字颜色  
8   label.textColor = [UIColor orangeColor];   
9   //设置文字排版方式     
10  label.textAlignment = UITextAlignmentRight;     
11  label.textAlignment = UITextAlignmentCenter;     
12  //设置字体大小适应label宽度     
13  label.adjustsFontSizeToFitWidth = YES;
14  //设置label的显示行数  
15  label.numberOfLines = 2; 
16  //背景色，也可以设置背景图   
17  label.backgroundColor=[UIColor clearColor]; //可以去掉背景色   
18  //设置高亮     
19  label.highlighted = YES;     
20  label.highlightedTextColor = [UIColor orangeColor];     
21  //设置阴影     
22  label.shadowColor = [UIColor redColor];     
23  label.shadowOffset = CGSizeMake(1.0,1.0);     
24  //设置是否能与用户进行交互     
25  label.userInteractionEnabled = YES;     
26  //设置label中的文字是否可变，默认值是YES     
27  label.enabled = NO;     
28  //设置文字过长时的显示格式     
29  label.lineBreakMode = UILineBreakModeMiddleTruncation;//截去中间     
30  //  typedef enum {     
31  //      UILineBreakModeWordWrap = 0,     
32  //      UILineBreakModeCharacterWrap,     
33  //      UILineBreakModeClip,//截去多余部分     
34  //      UILineBreakModeHeadTruncation,//截去头部     
35  //      UILineBreakModeTailTruncation,//截去尾部     
36  //      UILineBreakModeMiddleTruncation,//截去中间     
37  //  } UILineBreakMode;     
38  
</code></pre>

<h2 id="toc_2">UIButton</h2>

<pre><code>1   建立 //UIButton的定义
2   UIButton *button=[[UIButton buttonWithType:(UIButtonType);
3   //typedef enum {
4   //  UIButtonTypeCustom = 0, 自定义风格
5   //  UIButtonTypeRoundedRect, 圆角矩形
6   //  UIButtonTypeDetailDisclosure, 蓝色小箭头按钮，主要做详细说明用
7   //  UIButtonTypeInfoLight, 亮色感叹号
8   //  UIButtonTypeInfoDark, 暗色感叹号
9   //  UIButtonTypeContactAdd, 十字加号按钮
10  //} UIButtonType;
11  
12  常用方法//设置frame
13  button.frame = CGRectMake(20, 20, 280, 40);
14  [button setFrame:CGRectMake(20,20,50,50)];
15  
16  //button背景色
17  button.backgroundColor = [UIColor clearColor];
18  [button setBackgroundColor:[UIColor blueColor]];
19  
20  //是否可点击，默认为YES
21  button.enable = NO;                          
22  //设置button填充图片和背景图片
23  [button setImage:(UIImage) forState:UIControlStateNormal];
24  [button setBackgroundImage:(UIImage)forState:UIControlStateNormal];
25  //设置button标题和标题颜色
26  [button1 setTitle:@&quot;点击&quot; forState:UIControlStateNormal];
27  [button setTitleColor:[UIColor redColor] forState:UIControlStateNormal];
28  
29  //添加或删除事件处理
30  [button addTarget:self action:@selector(butClick:)forControlEvents:UIControlEventTouchUpInside];
31  [button removeTarget:nil action:nil forControlEvents:UIControlEventTouchUpInside];
32  
</code></pre>

<h2 id="toc_3">UIImageView</h2>

<pre><code>1   建立UIImageView *imageView = [[UIImageView alloc ] init];
2   //UIImage加载有两种方式
3   //方案1
4   UIImage *image = [UIImage imageNamed:@&quot;image_photo&quot;];
5   //方案2
6   NSString *filePath=[[NSBundle mainBundle] pathForResource:@&quot;image_photo&quot; ofType:@&quot;jpg&quot;];
7   UIImage *image=[UIImage imageWithContentsOfFile:filePath];
8   
9   imageView.image = image;
10   
</code></pre>

<p>方案一：用imageNamed的方式加载时，系统会把图像Cache到内存。如果图像比较大，或者图像比较多，用这种方式会消耗很大的内存，而且释放图像的内存是一件相对来说比较麻烦的事情。例如：如果利用imageNamed的方式加载图像到一个动态数组NSMutableArray，然后将将数组赋予一个UIView的对象的animationImages进行逐帧动画，那么这将会很有可能造成内存泄露。并且释放图像所占据的内存也不会那么简单。但是利用imageNamed加载图像也有自己的优势。对于同一个图像系统只会把它Cache到内存一次，这对于图像的重复利用是非常有优势的。例如：你需要在一个TableView里重复加载同样一个图标，那么用imageNamed加载图像，系统会把那个图标Cache到内存，在Table里每次利用那个图像的时候，只会把图片指针指向同一块内存。这种情况使用imageNamed加载图像就会变得非常有效。方案二：就是每次单独加载图片，系统不缓存。使用完后记得释放。</p>

<pre><code>1   常用方法 //设置圆角
2   imageView.layer.masksToBounds = YES;
3   imageView.layer.cornerRadius = 10;
4   
5   //设置边框颜色和大小
6   imageView.layer.borderColor = [UIColor orangeColor].CGColor;
7   imageView.layer.borderWidth = 2;
8   
9   //播放一系列图片
10  UIImage *image1 = [UIImage imageNamed:@&quot;1&quot;];
11  UIImage *image2 = [UIImage imageNamed:@&quot;2&quot;];
12  UIImage *image3 = [UIImage imageNamed:@&quot;3&quot;];
13  NSArray *imagesArray = @[image1,image2,image3];
14  imageView.animationImages = imagesArray;
15  // 设定所有的图片在多少秒内播放完毕
16  imageView.animationDuration = [imagesArray count];
17  // 重复播放多少遍，0表示无数遍
18  imageView.animationRepeatCount = 0;
19  // 开始播放
20  [imageView startAnimating];
21  
22   //为图片添加单击事件：一定要先将userInteractionEnabled置为YES，这样才能响应单击事件
23  imageView.userInteractionEnabled = YES;
24  UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapImageView:)];
25  [imageView addGestureRecognizer:singleTap];
26  
27  //其他设置
28  imageView.hidden = YES或者NO;    // 隐藏或者显示图片
29  imageView.alpha =0.5;    // 设置透明度
30  // 设置高亮时显示的图片
31  imageView.highlightedImage = (UIImage *)hightlightedImage;
32  imageView.image = (UIImage *)image; // 设置正常显示的图片
</code></pre>

<h2 id="toc_4">UITextField</h2>

<pre><code>1   建立UITextField* textField = [[UITextField alloc] initWithFrame:CGRectMake(x, y, width, height)];
2   
3   常用方法textField setBorderStyle:UITextBorderStyleRoundedRect]; //外框类型
4   textField.placeholder = @&quot;password&quot;; //默认显示的字 
5   textField.secureTextEntry = YES; //密码 
6   
7   textField.autocorrectionType = UITextAutocorrectionType; //设置是否自动纠错
8   typedef enum {
9       UITextAutocorrectionTypeDefault, //默认
10      UITextAutocorrectionTypeNo, 　//不自动纠错
11      UITextAutocorrectionTypeYes,　//自动纠错
12  }UITextAutocorrectionType;
13  
14  textField.clearButtonMode = UITextFieldViewMode; //编辑时会出现个修改X
15  typedef enum {
16      UITextFieldViewModeNever,　//重不出现
17      UITextFieldViewModeWhileEditing, //编辑时出现
18      UITextFieldViewModeUnlessEditing,　//除了编辑外都出现
19      UITextFieldViewModeAlways 　//一直出现
20  }UITextFieldViewMode; 
21  
22  //可以在UITextField使用下面方法，按return键返回
23  -(IBAction) textFieldDone:(id) sender
24  {
25   [textFieldName resignFirstResponder]; 
26  }
27  //链接TextField控件的&quot;Did end on exit&quot;
28  
29  //再次编辑就清空
30  textField.clearsOnBeginEditing = YES; 
31  
32  //设置键盘样式
33  textField.keyboardType = UIKeyboardType;
34  typedef enum {
35          UIKeyboardTypeDefault,     　//默认键盘，支持所有字符         
36          UIKeyboardTypeASCIICapable,　//支持ASCII的默认键盘
37          UIKeyboardTypeNumbersAndPunctuation,　//标准电话键盘，支持＋＊＃字符
38          UIKeyboardTypeURL,            //URL键盘，支持.com按钮 只支持URL字符
39          UIKeyboardTypeNumberPad,       //数字键盘
40          UIKeyboardTypePhonePad,　 　//电话键盘
41          UIKeyboardTypeNamePhonePad, 　//电话键盘，也支持输入人名
42          UIKeyboardTypeEmailAddress, 　//用于输入电子邮件地址的键盘     
43          UIKeyboardTypeDecimalPad,   　//数字键盘有数字和小数点
44          UIKeyboardTypeTwitter,      　//优化的键盘，方便输入@、#字符
45          UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable, 
46  }UIKeyboardType;
47  
48  //return键样式
49  text.returnKeyType =UIReturnKeyType;
50  typedef enum {
51      UIReturnKeyDefault, 默认 灰色按钮，标有Return
52      UIReturnKeyGo,    　标有Go的蓝色按钮
53      UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索
54      UIReturnKeyJoin,标有Join的蓝色按钮
55      UIReturnKeyNext,标有Next的蓝色按钮
56      UIReturnKeyRoute,标有Route的蓝色按钮
57      UIReturnKeySearch,标有Search的蓝色按钮
58      UIReturnKeySend,标有Send的蓝色按钮
59      UIReturnKeyYahoo,标有Yahoo的蓝色按钮
60      UIReturnKeyYahoo,标有Yahoo的蓝色按钮
61      UIReturnKeyEmergencyCall, 紧急呼叫按钮
62  } UIReturnKeyType;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C复习笔记(二)]]></title>
    <link href="http://ranchu90.github.io/14637124055346.html"/>
    <updated>2016-05-20T10:46:45+08:00</updated>
    <id>http://ranchu90.github.io/14637124055346.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ARC机制</h2>

<p>以往的OBJC是通过程序员手动地管理对象的释放。ARC(Automatic Reference Counting)自动引用计数，现在是OBJC的默认内存管理机制，针对堆上的对象，由编译器自动生成操作引用计数的指令(retain,release)来管理对象的释放。</p>

<h3 id="toc_1">管理的对象</h3>

<table>
<thead>
<tr>
<th>受ARC管理</th>
<th>不受ARC管理</th>
</tr>
</thead>

<tbody>
<tr>
<td>OC对象指针</td>
<td>值类型(基本类型，struct)</td>
</tr>
<tr>
<td>Block指针</td>
<td>其他方式分配的资源(c语言的malloc)</td>
</tr>
<tr>
<td>使用_attribute_((NSObject))定义的typedef</td>
<td>非内存资源</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">管理的方式</h3>

<pre><code>//新创建一个引用类型的对象，这个对象的引用计数初始为1；
NSString *name = [[NSString alloc] initWithString:@&quot;Mono&quot;];
//将对象引用赋值给其它变量或者常量，引用计数+1；
NSString *otherName = name;
//或者将将该对象引用赋值给其它对象的属性或实例变量，引用计数+1；
person.name = name;
//将对象传入函数参数，或者返回值，引用计数+1
print(name);//函数结束后，参数或者局部变量离开函数，该对象的引用计数-1；
//将对象加入集合之中，引用计数+1；
[array addObject];

//将变量或者常量,或者属性赋值为nil或者其他值，引用计数-1；
otherName = nil; or otherName = @&quot;Other Name&quot;;
person.name = nil;
//实例变量和属性所在的对象呗释放，该对象引用计数-1；
[person release];
//将对象从集合中移除的时候，该对象的引用计数-1；
[array removeObject:name];

//当该对象的引用计数变为0的时候，内存自动被释放。
</code></pre>

<h2 id="toc_3">自动释放池(Autorelease Pool)</h2>

<p>如果对象频繁的进行释放和分配，那么会造成琐碎的内存管理负担。autorelease可以讲release的调用延迟到自动释放池被释放时。</p>

<p>当自动释放池结束时，所有接受autorelease消息的对象都将被立即释放(对象被发送一条release消息);</p>

<p>AppKit和UIKit框架在处理每一次事件循环迭代时，都会讲其放入一个Autorelease Pool中，大多数情况无须程序员干预。</p>

<h3 id="toc_4">需要手动管理Autorelease Pool的情况</h3>

<p>1.当编写的程序不是基于UI框架，而是命令行程序时。<br/>
2.如果在循环中创建大量临时对象，需要更早地释放，避免临时对象聚集导致内存峰值过大。<br/>
3.在主线程之外创建新的线程，在新线程开始执行处，需要创建自己的Autorelease Pool。<br/>
4.嵌套使用Autorelease Pool的时候。</p>

<h2 id="toc_5">协议 Protocol</h2>

<p>类型的合同约定，只描述外部接口，不提供具体的实现。<br/>
协议中无法包含实例变量，但可以包含以下的成员：<br/>
属性 （本质上是访问器方法，编译器不会合成实例变量）<br/>
实例方法<br/>
类方法<br/>
初始化器，析构器(不常用)</p>

<h3 id="toc_6">使用协议</h3>

<p>1.一个类遵守协议，需实现该协议约定的所有@required的成员，即必须要实现的成员。<br/>
协议中的属性必须在实现类的.h接口文件中声明(编译器合成实例变量)<br/>
2.协议本质上是一种类型，可以作为声明类型，但是不能创建实例。<br/>
3.可以使用conformsToProtocl:检查是否实现了协议。<br/>
4.编译警告：1）未实现必选方法。2）协议类型变量被赋值为非协议类型变量。运行会出错。</p>

<h4 id="toc_7">协议的继承</h4>

<p>一个协议可以继承一个或者多个协议。<br/>
实现子协议的类型，同时也要实现父协议中必须是实现的成员。</p>

<h4 id="toc_8">协议的组合</h4>

<p>一个类可以同时实现多个协议，protocal<A,B,C....>来组合多个协议<br/>
实现组合协议的类型，必须实现组合协议中的每一个协议</p>

<h4 id="toc_9">协议中的可选</h4>

<p>协议中使用关键字@optional定义的成员是可以选择不必实现的。</p>

<h3 id="toc_10">常用的协议</h3>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>NSObject</td>
<td>包含对象的常用操作，相等、字符串表示、哈希。</td>
</tr>
<tr>
<td>NSCopying</td>
<td>支持复制的类型必须遵守该协议。</td>
</tr>
<tr>
<td>NSMutableCopying</td>
<td>在NSCopying协议的基础上，支持复制数据的可变性。</td>
</tr>
<tr>
<td>NSFastEnumeration</td>
<td>实现快速枚举for-in的类型采用</td>
</tr>
<tr>
<td>NSCoding</td>
<td>支持将对象图进行编码或解码以支持对象的序列化</td>
</tr>
</tbody>
</table>

<h2 id="toc_11">类别 Categroy</h2>

<p>在没有源代码的情况下，基于某些场合的需要，为一个类增加功能。<br/>
可增加 | 不可增加<br/>
--------- | -------------<br/>
类方法 | 属性<br/>
实例方法| 实例变量<br/>
重写父类方法 | 已存在的同名方法</p>

<h3 id="toc_12">命名规范</h3>

<p>文件名：类名+扩展方法，如：Person+Sport.h/m</p>

<h3 id="toc_13">类别的使用</h3>

<h4 id="toc_14">场景</h4>

<p>1.适合在没有源代码的情况下，想已经封装的类中添加方法。<br/>
2.为一个类在某些特殊场景下增加功能。<br/>
3.对于复杂的大型文件分割实现。<br/>
4.可以通过类别重写现有方法，但一般不推荐，这样会导致无法调用被扩展的类的初始方法，只能访问重写过的方法。</p>

<h4 id="toc_15">添加类别的对象</h4>

<p>1.自己创建的类。<br/>
2.系统的类。<br/>
3.第三方库。</p>

<h4 id="toc_16">类别限制</h4>

<p>1.类别不能在扩展类中添加任何成员变量。<br/>
2.重写现有方法时，无法调用原始现有对象方法。<br/>
3.若两个类别都定义了一个相同类的相同方法，运行时实际无法确定调用哪一个。</p>

<h2 id="toc_17">扩展 Extension</h2>

<p>扩展支持在编译时，在有类的源代码的前提下，向类添加功能。可看做是匿名的类别。</p>

<p>接口在.m文件中的@implementation前声明，实现代码在@implementation 内实现。</p>

<p>扩展支持添加以下成员：<br/>
1.属性。<br/>
2.实例成员。<br/>
3.类方法。<br/>
4.实例方法。<br/>
5.改写属性的读写属性。</p>

<h3 id="toc_18">扩展的使用</h3>

<p>扩展实现的成员只能在。m文件内部访问，类外无法直接往访问。</p>

<p>扩展的主要用途在于信息隐藏，隐藏一些外部无须访问、而内部实现又需要使用的属性、方法：<br/>
1.类的主要接口用于“对类以外公开”<br/>
2.类的扩展接口用于“对类内可见”</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C复习笔记]]></title>
    <link href="http://ranchu90.github.io/14632363806380.html"/>
    <updated>2016-05-14T22:33:00+08:00</updated>
    <id>http://ranchu90.github.io/14632363806380.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Objective-C简介</h2>

<p>Objective-C简称Objc或者OC，是一种基于C语言的面向对象程序设计语言。1980年代产生，主要在苹果电脑平台上使用，开发Cocoa或Cocoa Touch应用程序。<br/>
通过LLVM编译器架构，可以苹果家最新的编程语言Swift进行双向操作。不过终有一天将会被Swift取代。</p>

<h3 id="toc_1">开发方式</h3>

<h4 id="toc_2">命令行</h4>

<p>clang -fobj-arc *.m<br/>
-fobj-arc表示支持ARC内存管理<br/>
适合研究、调试、学习</p>

<h4 id="toc_3">IDE</h4>

<p>通过Xcode构建正规工程项目<br/>
有利于构建高质量的代码组织</p>

<h2 id="toc_4">类与对象</h2>

<p>在OC中所有的类都是引用类型，所有c语言中的基本数值类型都是值类型。此外，详细的类型说明如下表所示：</p>

<table>
<thead>
<tr>
<th>引用类型(reference)</th>
<th>值类型(value type)</th>
<th>类型装饰</th>
</tr>
</thead>

<tbody>
<tr>
<td>类 class</td>
<td>基础数值类型</td>
<td>协议 protocol</td>
</tr>
<tr>
<td>指针 pointer</td>
<td>结构 struct</td>
<td>类别 category</td>
</tr>
<tr>
<td>快 block</td>
<td>枚举 enum</td>
<td>扩展 extension</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">类与结构体的区别</h3>

<table>
<thead>
<tr>
<th></th>
<th>类 class</th>
<th>结构 struct</th>
</tr>
</thead>

<tbody>
<tr>
<td>实例</td>
<td>对象</td>
<td>值</td>
</tr>
<tr>
<td>类型</td>
<td>引用类型(栈：指针，堆：实体对象)</td>
<td>实例直接存在在栈中</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">栈和堆的区别</h3>

<table>
<thead>
<tr>
<th></th>
<th>栈 stack</th>
<th>堆 heap</th>
</tr>
</thead>

<tbody>
<tr>
<td>存储类容</td>
<td>值类型</td>
<td>引用类型的对象</td>
</tr>
<tr>
<td>管理方式</td>
<td>由系统自动管理，函数为单位</td>
<td>分配由程序员手动请求</td>
</tr>
<tr>
<td>具体</td>
<td>空间大小编译时确定(参数+全局变量)</td>
<td>释放由运行时ARC机制自动释放(确定是)</td>
</tr>
<tr>
<td>具体</td>
<td>函数执行时，系统自动分配stack</td>
<td></td>
</tr>
<tr>
<td>具体</td>
<td>函数结束后，系统立即自动回收stack</td>
<td></td>
</tr>
<tr>
<td>传递方式</td>
<td>函数间直接通过拷贝值传递</td>
<td>函数间通过拷贝引用(指针)传递</td>
</tr>
<tr>
<td>限制</td>
<td>有局部性，大小有限额，超出stack overflow</td>
<td>有全局性，无大小限制(受制系统内存大小)</td>
</tr>
</tbody>
</table>

<h2 id="toc_7">属性与实例变量</h2>

<p>数据成员描述对象的状态：1.实例变量instance variable。2.属性property。</p>

<h3 id="toc_8">属性</h3>

<p>属性描述的是对象的状态，是对外的接口(相当于是public)。<br/>
声明一个属性的同时，编译器会自动为这个属性生成：<br/>
1.getter访问器方法: properyName<br/>
2.setter访问器方法: setProperyName<br/>
3.一个对应的实例变量: _propery</p>

<p>访问器方法可以自定义。访问器方法名也可以修改。对应的实例变量名也可以修改。但是一般使用编译器默认生成的，以便统一规范。</p>

<p>使用静态全局变量(c语言)+类方法，可以模拟类属性。</p>

<h3 id="toc_9">实例变量</h3>

<p>可在不声明属性的情况下定义实例变量。只有实例变量，无类变量。<br/>
若单独自定义了访问器方法，则编译器就不在合成实例变量。<br/>
类外使用属性来访问，类内一般也是用属性访问即self.<br/>
以下情况例外：<br/>
初始化器 init<br/>
析构器 dealloc<br/>
自定义访问器方法中</p>

<p>生存周期<br/>
实例变量存储在堆上。<br/>
值类型实例变量内嵌在对象实例中，随着对象实例释放。<br/>
引用类型的实例变量通过指针引用堆上的实例，ARC对引用进行计数管理，自动施放。</p>

<p>属性的描述特性<br/>
Attribute可指定属性的不同功能。</p>

<p>读写： readwrite(默认)，readonly<br/>
多线程： atomic(默认)， nonatomic</p>

<p>内存管理特性<br/>
ARC下：<br/>
strong(默认), weak(阻止循环引用), copy(创建独立拷贝)<br/>
MRC下：<br/>
retain<br/>
assign<br/>
unsafe_unretained</p>

<h2 id="toc_10">方法</h2>

<p>函数成员描述对象的行为：1.方法method。2.初始化器init。3.析构器dealloc。</p>

<p>函数指的是代码段上可执行指令序列，OC中称为方法。<br/>
所有的方法默认都是公有的，没有private和protected。<br/>
方法调用通过运行时动态消息分发实现，OC中称为向对象发送消息。</p>

<h3 id="toc_11">方法的类型</h3>

<p>实例方法，可访问：<br/>
实例成员。<br/>
类型方法、静态变量。</p>

<p>类方法<br/>
可访问：类型方法、静态变量<br/>
无法访问实例成员。</p>

<h3 id="toc_12">方法的参数</h3>

<p>参数为值类型，则为值传递方式；为引用类型，则为指针传递；<br/>
方法可以无参数和返回值。</p>

<h2 id="toc_13">初始化器和析构器</h2>

<p>初始化器用于初始化对象实例或类型：<br/>
对象初始化：-(id) init 可以重载多个<br/>
alloc：1.在堆上分配合适大小内存。2.将属性或实例变量的内存置0。<br/>
init：1.调用父类初始化器[super init]。2.初始化当前对象实例变量。<br/>
new相当于alloc/init的无参数版本。<br/>
类型初始化：+(void) initialize 只能一个<br/>
负责类型级别初始化。<br/>
每个类使用前被系统自动调用，每个进程周期只调用一次。<br/>
子类调用父类的initialize方法。</p>

<p>析构器用于释放对象的资源，无返回值。<br/>
只能一个。<br/>
无类型析构器。</p>

<p>自动：ARC将对象属性引用计数减持。<br/>
手动：1.释放不受ARC管理的动态内存，如malloc。<br/>
     2.关闭非内存资源，如文件句柄，网络资源。</p>

<p>dealloc由ARC自动在释放对象内存前调用，无法手工调用。<br/>
子类dealloc会自动调用父类的dealloc(后置调用)。</p>

<h2 id="toc_14">继承与多态</h2>

<p>继承的含义：<br/>
成员复用：子类复用父类成员<br/>
类型抽象：将子类当做父类使用(IS-A关系准则)</p>

<p>多态：<br/>
子类在父类统一行为接口下，表现不同的实现方式。</p>

<p>OC不支持重载，子类只能重写与父类同名同参数方法。</p>

<p>子类中通过super调用父类实现。<br/>
self具有多态性，可以指向不同的子类。<br/>
super无多态性，仅指向当前父类。</p>

<h3 id="toc_15">init和dealloc的继承</h3>

<p>init：<br/>
子类自动继承父类的初始化器。<br/>
子类也可以重写父类的初始化器，此时子类初始化器必须先调用父类的一个初始化器。</p>

<p>dealloc：<br/>
子类可以选择继承父类析构器或者重写父类析构器。<br/>
子类析构器执行完后会自动调用父类的析构器（后置调用，且不支持手工调用）。<br/>
子类析构器自动具有多态性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中的协议]]></title>
    <link href="http://ranchu90.github.io/14609059782704.html"/>
    <updated>2016-04-17T23:12:58+08:00</updated>
    <id>http://ranchu90.github.io/14609059782704.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一.问题的产生</h2>

<p><img src="media/14609059782704/14609061125330.jpg" alt=""/><br/>
NetworkConnector类提供所有和网络服务器的交互，包括连接、断开连接和手法数据。BusinessLogic类会接收NetworkConnector收到的数据，并确定它的走向。<br/>
网络连接是一个在其他应用或同一个应用的其他地方一定会复用的东西。所以必须将它与BusinessLogic类设计成没有紧密耦合。<br/>
<img src="media/14609059782704/14609063607549.jpg" alt=""/><br/>
C++等语言使用多继承来解决这类问题，强制BusinessLogic类继承自NetworkConnector可以依赖的类。但是多继承会产生新的问题，即砖石问题。如果D类同时继承自B类和C类，同时B、C也继承自共同的超类A，这种情况下，如果D没有重写A中的方法，当D调用A类的方法的时候，无法确定会调用哪一个父类的方法B类的还是C类的？<br/>
Objective-C只能使用单继承。 </p>

<h2 id="toc_1">二.Objective-C的解决方案</h2>

<p>Objective-C使用协议来声明一个接口来解决这个问题。<br/>
接口是在不提供默认实现时由一个类来具体实现，它只提供声明这些方法的接口机制，让可复用组件不依赖于特定的类来实现，而依赖于以协议形式存在的接口。</p>

<h3 id="toc_2">协议的声明</h3>

<pre><code>@protocol NetworkClient
@required
-(void) networkConnector:(NetworkConnector *) in gotData:(NSData *) data;
@optional
-(void) networkConnectorDisconnected:(NetworkConnector *) in;
@end

</code></pre>

<p>@required关键字表明其后的方法是该协议必须实现的方法。<br/>
@optional关键字表明其后的方法是实现类可以选择性实现的方法。<br/>
同时，协议不能有成员变量。</p>

<h3 id="toc_3">声明一个必须实现协议的对象</h3>

<pre><code>id&lt;NerworkClient&gt; *delegate; //&lt;&gt;中是该对象必须实现的协议
</code></pre>

<p>通常使用id数据类型来声明实现给定协议的实例变量。编译器会通过&lt;&gt;中的协议类型来确认协议的必须按方法是否在该对象上实现了。</p>

<h3 id="toc_4">非正式协议</h3>

<p>它是在Cocoa和Objective-C中的旧协议，通常是NSObject类的类别。</p>

<h3 id="toc_5">正式协议</h3>

<p>正式协议可以提供更好的类型安全。用@protocol关键字来声明。有@required和@optional关键字来保证必须实现的和可选的方法。</p>

<h3 id="toc_6">避免协议循环依赖</h3>

<p>协议在各自的声明中可以引用另一个协议。</p>

<pre><code>@protocol Foo
-(void)someMethodRequiringBar:(id&lt;Bar&gt;)inBar;
@end
</code></pre>

<p>如果Bar也需要Foo协议的话，就会导致协议之间的循环依赖，发生编译器错误。</p>

<pre><code>@protocol Bar
-(void)someMethodRequiringFoo:(id&lt;Foo&gt;)inFoo;
@end
</code></pre>

<p>解决方法，在Bar.h中加入@protocol Foo，告诉编译器Foo是一个协议，不用导入Foo.h。</p>

]]></content>
  </entry>
  
</feed>
