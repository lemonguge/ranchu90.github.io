<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[cd's blog]]></title>
  <link href="http://ranchu90.github.io/atom.xml" rel="self"/>
  <link href="http://ranchu90.github.io/"/>
  <updated>2016-10-07T22:14:37+08:00</updated>
  <id>http://ranchu90.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[30. Java IO与NIO]]></title>
    <link href="http://ranchu90.github.io/14759831063023.html"/>
    <updated>2016-10-09T11:18:26+08:00</updated>
    <id>http://ranchu90.github.io/14759831063023.html</id>
    <content type="html"><![CDATA[
<p>NIO，全称non-blocking IO，由jdk1.4推出，它是一种非阻塞的IO方式，为所有的基本类型提供了缓存支持。</p>

<p>IO操作包括，对硬盘的读写，对socket的读写及外设的读写。</p>

<p>阻塞和非阻塞<br/>
阻塞：当某个事件或任务执行过程中，它发出一个请求操作，当该请求所需的条件不满足时，该事件会一直停留在这里，等待直到条件满足。</p>

<p>非阻塞：当某个事件或任务执行过程中，它发出一个请求操作，当该请求所需的条件不满足时，会立即返回一个标志信息告知条件不满足，不会一直等待条件满足。</p>

<p>阻塞IO和非阻塞IO<br/>
当用户发起一个IO请求操作，内核会去查看要读取的数据是否就绪。<br/>
对于阻塞IO，如果数据没有准备就绪，就一直等待知道数据就绪。<br/>
对于非阻塞IO来说，如果数据没准备就绪，就返回一个标识信息告诉用户线程当前的数据没有准备就绪。数据准备就绪后，便将数据拷贝到用户线程，完成一整个完整的IO请求操作。</p>

<p>完整的IO请求包括两个阶段：<br/>
1）查看数据是否就绪<br/>
2）进行数据拷贝（内核将数据拷贝到用户线程）</p>

<p>阻塞IO和非阻塞IO区别在于第一个阶段，没有数据的时候是一直等待还是返回一个标志信息。</p>

<p>同步IO和异步IO：<br/>
       从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；<br/>
　　而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。<br/>
　　事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：<br/>
　　对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；<br/>
　　而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[29. foreach与正常for循环效率对比]]></title>
    <link href="http://ranchu90.github.io/14759174977641.html"/>
    <updated>2016-10-08T17:04:57+08:00</updated>
    <id>http://ranchu90.github.io/14759174977641.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>for</th>
<th>foreach</th>
</tr>
</thead>

<tbody>
<tr>
<td>跳跃访问</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>修改当前访问值</td>
<td>能（但不能删除）</td>
<td>否</td>
</tr>
<tr>
<td>集合类型</td>
<td>效率稍高</td>
<td>稍低</td>
</tr>
<tr>
<td>数组类型</td>
<td>效率稍低</td>
<td>稍高</td>
</tr>
<tr>
<td>链表LinkedList</td>
<td>稍低</td>
<td>稍高</td>
</tr>
</tbody>
</table>

<p>两种方式在遍历数组的时候时间普遍都较快，在遍历集合的时候耗时会更久一些。在遍历数组时，foreach的表现要稍微好一点，在遍历集合的时候，for的表现要好一点。但是不管哪种情况，for和foreach这两种遍历方式时间都相差不大。因此对于这两者的比较在时间效率来说应该相差不会很大（上面没有测试复杂数据的情况，以及其他集合结果的情况，可能不准确）。主要是在对于两者的应用场景上的选择：<br/>
（1）普通for循环可以根据下标来访问；<br/>
（2）foreach在代码结构上更加清晰、简单；<br/>
（3）foreach在遍历的时候会锁定集合中的对象，期间不能修改，而for能对集合中的元素进行修改。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[28. wait()和sleep()的区别]]></title>
    <link href="http://ranchu90.github.io/14759170796736.html"/>
    <updated>2016-10-08T16:57:59+08:00</updated>
    <id>http://ranchu90.github.io/14759170796736.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>wait()</th>
<th>sleep()</th>
</tr>
</thead>

<tbody>
<tr>
<td>原理</td>
<td>Object的方法，用于线程通信</td>
<td>Thread的静态方法</td>
</tr>
<tr>
<td>对锁的处理机制</td>
<td>释放资源给其它线程使用，在调用notify或notifyAll之后，重新参与争夺资源</td>
<td>只是放cpu，时间到即恢复运行，不涉及线程通信</td>
</tr>
<tr>
<td>使用区域</td>
<td>必须在同步控制方法或语句块中使用(synchronized)</td>
<td>可在任何地方</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th></th>
<th>sleep</th>
<th>yield</th>
</tr>
</thead>

<tbody>
<tr>
<td>运行机会</td>
<td>会给低优先级的线程机会运行</td>
<td>只给相同优先级或更高的线程运行</td>
</tr>
<tr>
<td>转入状态</td>
<td>使线程转入阻塞状态，短时间内部执行</td>
<td>使线程转入可执行状态，可参与竞争cpu，所以可能该线程立即又被执行</td>
</tr>
<tr>
<td>异常</td>
<td>抛出InterruptedException</td>
<td>无</td>
</tr>
<tr>
<td>移植性</td>
<td>比yield高</td>
<td>与操作系统相关</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[26. ThreadPool用法与优势]]></title>
    <link href="http://ranchu90.github.io/14757460203014.html"/>
    <updated>2016-10-06T17:27:00+08:00</updated>
    <id>http://ranchu90.github.io/14757460203014.html</id>
    <content type="html"><![CDATA[
<p>线程池的优势<br/>
合理利用线程池能够带来三个好处。</p>

<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</li>
</ul>

<p>Java通过Executors提供四种线程池，分别为： </p>

<ul>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </li>
<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 </li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 </li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>

<p>使用方式</p>

<p>execute();<br/>
submit();</p>

<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
</code></pre>

<p>参考文献<br/>
<a href="http://itindex.net/detail/48147-java-%E7%BA%BF%E7%A8%8B">http://itindex.net/detail/48147-java-%E7%BA%BF%E7%A8%8B</a><br/>
<a href="http://blog.csdn.net/scboyhj__/article/details/48805881">http://blog.csdn.net/scboyhj__/article/details/48805881</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[25. ThreadLocal的设计理念与作用]]></title>
    <link href="http://ranchu90.github.io/14753108824439.html"/>
    <updated>2016-10-01T16:34:42+08:00</updated>
    <id>http://ranchu90.github.io/14753108824439.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">目的</h3>

<p>多线程共享一个变量，可以通过public static的形式来实现。<br/>
每一个线程都有自己的共享变量，提出ThreadLocal正是解决这样的问题。<br/>
ThreadLocal类主要解决每个线程绑定自己的值，打个比方，类似全局的存放数据的盒子，盒子中可以存放每个线程的私有数据。</p>

<h3 id="toc_1">常用的方法</h3>

<pre><code>T get();

void set(T value);

protected T initialValue() {
        return null;
}
</code></pre>

<p>get()用来获取本地线程中存放的值，set()用来设置本地线程中的值。<br/>
覆盖initialValue()可以设定指定的初始值，若不设定，初始值默认为null。</p>

<p>线程变量是隔离的，即每个线程只能访问自己的值，他们有各自的初始值。</p>

<h3 id="toc_2">InheritableThreadLocal</h3>

<p>使用InheritableThreadLocal可以继承父线程中的值，并可以通过覆盖childValue方法来修改继承的值。</p>

<h3 id="toc_3">示例</h3>

<pre><code>package com.cd.threadlocal;

public class Tools {

    public static ThreadLocalDefined&lt;String&gt; tl = new ThreadLocalDefined&lt;String&gt;();
    
    public Tools() {
        // TODO Auto-generated constructor stub
    }

}

package com.cd.threadlocal;

public class ThreadLocalDefined&lt;T&gt; extends ThreadLocal&lt;Object&gt; {

    @Override
    protected Object initialValue() {
        // TODO Auto-generated method stub
        return &quot;OK&quot;;
    }

}

package com.cd.threadlocal;

public class ThreadA extends Thread {

    public ThreadA() {
        // TODO Auto-generated constructor stub
    }

    @Override
    public void run() {
        for(int i=0; i&lt;10; ++i){
            if(Tools.tl.get() == null){
                System.out.println(&quot;ThreadA 1st &quot; + Tools.tl.get());
            }
            
            System.out.println(Tools.tl.get());
            Tools.tl.set(&quot;Thread A &quot;+ i);
        }
    }
}

package com.cd.threadlocal;

public class Main {

    public Main() {
        // TODO Auto-generated constructor stub
    }

    public static void main(String[] args) {
        
        ThreadA a = new ThreadA();
        a.start();
        
        for(int i=0; i&lt;10; ++i){
            if(Tools.tl.get() == null){
                System.out.println(&quot;Main 1st &quot; + Tools.tl.get());
            }
            
            System.out.println(Tools.tl.get());
            Tools.tl.set(&quot;Main Thread &quot;+i);
        }

    }

}

</code></pre>

<p>运行结果</p>

<pre><code>OK
OK
Main Thread 0
Thread A 0
Main Thread 1
Thread A 1
Thread A 2
Main Thread 2
Thread A 3
Main Thread 3
Thread A 4
Thread A 5
Main Thread 4
Thread A 6
Main Thread 5
Thread A 7
Main Thread 6
Thread A 8
Main Thread 7
Main Thread 8
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[24. 写出生产者消费者模式]]></title>
    <link href="http://ranchu90.github.io/14753034865723.html"/>
    <updated>2016-10-01T14:31:26+08:00</updated>
    <id>http://ranchu90.github.io/14753034865723.html</id>
    <content type="html"><![CDATA[
<p>参照网络上的资料，自己写了一个生产者消费者模式。</p>

<pre><code>package com.cd.test;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class Main {

    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        
        Container container = new Container();
        
        Producer a = new Producer(container, &quot;Wang Sir&quot;);
        Producer b = new Producer(container, &quot;Li Sir&quot;);
        Consumer c = new Consumer(container, &quot;Chen&quot;);
        Consumer d = new Consumer(container, &quot;Opp&quot;);
        Consumer e = new Consumer(container, &quot;Satoshi&quot;);
        
        service.submit(a);
        service.submit(b);
        service.submit(c);
        service.submit(d);
        service.submit(e);
    }

}

class Goods {
    int no;
    String producer;
    
    Goods(int no, String producer){
        this.no = no;
        this.producer = producer;
    }
    
    public String toString(){
        return &quot;product :&quot; + no + &quot; by &quot; + this.producer;
    }
}

class Container {
    BlockingQueue&lt;Goods&gt; queue = null;
    int index = 0;
    int max = 0;
    
    Container(int num){
        if(num &gt; 0){
            queue = new ArrayBlockingQueue&lt;Goods&gt;(num);
            max = num;
        }
        else{
            queue = new ArrayBlockingQueue&lt;Goods&gt;(10);
            max = 10;
        }
    }

    Container(){
        this(10);
    }
    
    synchronized public Goods pop() throws InterruptedException{
        if(queue == null || queue.isEmpty())
            return null;
        
        Goods tmp = queue.take();
        
        return tmp;
    }
    
    synchronized public boolean push(Goods good) throws InterruptedException{
        if(queue == null || queue.size() == max)
            return false;
        
        queue.put(good);
        
        return true;
    }
}

class Producer implements Runnable{
    Container container = null;
    String producer = null;
    
    Producer(Container ct, String producer){
        this.container = ct;
        this.producer = producer;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        int index = 0;
        
        while(index &lt; 5){
            Goods good = new Goods(index++, this.producer);
            
            try {
                container.push(good);
                System.out.println(&quot; Produced goods :&quot; + good.toString());
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
    
}

class Consumer implements Runnable{
    Container container = null;
    String producer = null;
    
    Consumer(Container ct, String producer){
        this.container = ct;
        this.producer = producer;
    }
    
    @Override
    public void run() {
        // TODO Auto-generated method stub
        while(true){
            Goods good;
            
            try {
                good = container.pop();
                
                System.out.println(&quot; Consumed goods :&quot; + good.toString());
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            
        }
    }
    
}
</code></pre>

<p>其中一次的运行结果</p>

<pre><code> Produced goods :product :0 by Wang Sir
 Produced goods :product :1 by Wang Sir
 Produced goods :product :2 by Wang Sir
 Produced goods :product :3 by Wang Sir
 Produced goods :product :4 by Wang Sir
 Produced goods :product :0 by Li Sir
 Produced goods :product :1 by Li Sir
 Consumed goods :product :0 by Wang Sir
 Consumed goods :product :0 by Li Sir
 Consumed goods :product :1 by Wang Sir
 Consumed goods :product :2 by Wang Sir
 Consumed goods :product :3 by Wang Sir
 Consumed goods :product :4 by Wang Sir
 Produced goods :product :2 by Li Sir
 Consumed goods :product :1 by Li Sir
 Consumed goods :product :2 by Li Sir
 Produced goods :product :3 by Li Sir
 Consumed goods :product :3 by Li Sir
 Produced goods :product :4 by Li Sir
 Consumed goods :product :4 by Li Sir

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[23. 锁的等级：方法锁、对象锁、类锁]]></title>
    <link href="http://ranchu90.github.io/14752943139261.html"/>
    <updated>2016-10-01T11:58:33+08:00</updated>
    <id>http://ranchu90.github.io/14752943139261.html</id>
    <content type="html"><![CDATA[
<p>synchornized锁的对象可以是方法、对象、和类。</p>

<p>比如</p>

<pre><code>class Test {
    public int share;
    public static share2;
    
    synchronized public void getShare(){
        
        Thread.sleep(5000);
        
        return share;
    }
    
    synchronized public void getShare2(){
        
        Thread.sleep(5000);
        
        return share;
    }
    
    public void print(){
        
        System.out.println(&quot;print test&quot;);
    }
    
    static public void print(String ok){
        
        System.out.println(&quot;print test : &quot; + ok);
    }
}
</code></pre>

<p>如果对Test的实例上锁，那么其它的线程就无法访问该实例的synchronized方法，但是可以访问该实例没有synchronized的方法和静态的方法。<br/>
如果该方法内部调用了wait()方法，那么其它的线程可以访问该对象的synchronized方法。</p>

<p>如果对Test这个类上锁，那么该类的静态方法不能被其它的线程访问。但是实例方法可以被访问到，如果该实例为被上锁的话。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[22. 线程同步的方法：synchronized、lock、reentrantLock]]></title>
    <link href="http://ranchu90.github.io/14752937281313.html"/>
    <updated>2016-10-01T11:48:48+08:00</updated>
    <id>http://ranchu90.github.io/14752937281313.html</id>
    <content type="html"><![CDATA[
<p>sychronized用法两种1)锁方法2）锁对象（sychronized块），可作用于静态方法、类、实例。对效率有较大影响。</p>

<p>Lock是jdk5新增的一个接口，reentrantLock是它的一个实现类。</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>lock()</td>
<td>以阻塞的方式获取锁</td>
</tr>
<tr>
<td>tryLock()</td>
<td>以非阻塞的方式获取。如取得锁立即返回true，否则false。</td>
</tr>
<tr>
<td>tryLock(long timeout, TimeOut unit)</td>
<td>取得锁返回true；否则等待给定的单元时间，等待中获得锁返回true，等待结束，返回fasle。</td>
</tr>
<tr>
<td>lockInterruptibly()</td>
<td>获得所立即返回，否则当前线程处于阻塞状态直到获得锁，这个过程中，该线程可以被别的线程中断(InterruptedException)</td>
</tr>
</tbody>
</table>

<p>synchronized和lock的区别<br/>
总的来说可以从用法，性能，锁的机制及功能上来区别。</p>

<table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>lock</th>
</tr>
</thead>

<tbody>
<tr>
<td>用法</td>
<td>需要同步的对象中，1）锁方法，2）特定的代码块(锁对象或类），给JVM托管</td>
<td>需要显示地指定起始位置和终止位置。更精准的线程语义</td>
</tr>
<tr>
<td>性能</td>
<td>资源竞争不激烈时，优于lock，激烈时，性能下降很快</td>
<td>ReentrantLock性能比较稳定</td>
</tr>
<tr>
<td>锁机制</td>
<td>锁的获得与释放都在块结构中，获得多个锁，以相反的顺序释放，自动释放</td>
<td>手动释放做，必须在finally中释放。</td>
</tr>
<tr>
<td>功能</td>
<td>无法非阻塞获取锁，进入临界区无法中断，必须阻塞等待释放资源</td>
<td>包含synchronized的功能，提供非阻塞方式获取所、可中断线程的功能</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[21. 实现多线程的两种方法：Thread与Runnable]]></title>
    <link href="http://ranchu90.github.io/14752420902330.html"/>
    <updated>2016-09-30T21:28:10+08:00</updated>
    <id>http://ranchu90.github.io/14752420902330.html</id>
    <content type="html"><![CDATA[
<p>实现多线程在java中有三种方法，前两种比较常用。</p>

<h3 id="toc_0">继承Thread</h3>

<p>1）继承Thread类，重写run方法</p>

<pre><code>class MyThread extends Thread {
    @Override
    public void run(){
        
    }
}
</code></pre>

<h3 id="toc_1">实现Runnable</h3>

<p>2）实现Runnable接口<br/>
1.重写run方法，实例化后，再创建一个Thread的对象，将其传入Thread（object）方法中<br/>
2.创建一个Thread对象，使用匿名内部类实现Runnable接口。</p>

<p>Runnable接口中只声明了一个方法，返回类型为void。</p>

<pre><code>public interface Runnable {
    public abstract void run();
}
</code></pre>

<pre><code>class MyThread implements Runnable {
    @Override
    public void run(){
        System.out.println(&quot;runnable&quot;);
    }
}

class Main {
    public static void main(String[] args) {
        MyThread th = new MyThread();
        Thread run = new Thread(th);
        Thread run2 = new Thread(new Runnable(){
            public void run(){
                System.out.println(&quot;inner runnable&quot;);
            }
        });
        
        run.start();
        run2.start();
    }
}
</code></pre>

<h3 id="toc_2">实现Callable</h3>

<p>3）实现Callable（）接口，重写Call方法。<br/>
前两种创建线程的方式都包含一个缺陷，在执行完任务后无法获得执行结果。如果要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果。</p>

<p>Callable接口位于java.util.concurrent下，只包含一个方法。</p>

<pre><code>public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
</code></pre>

<p>Callable一般配合ExecutorService接口中的submit方法来使用。</p>

<pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
Future&lt;?&gt; submit(Runnable task);
</code></pre>

<h4 id="toc_3">Future</h4>

<p>java.util.concurrent<br/>
Future用于对具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。可以通过get()获取其执行结果，这个方法或阻塞知道获得任务返回的结果。</p>

<pre><code>public interface Future&lt;V&gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>

<ul>
<li><p>cancel用来取消任务，若取消成功则返回true，取消失败则返回false。mayInterruptIfRunning用于表示是否取消（中断）正在执行却没有完成的任务，true表示可以取消。任务未开始执行和任务执行完成时，无论其值为true或false，都返回false，取消失败。若果任务正在执行，其值为true，则返回true，其值为false，则返回fasle。</p></li>
<li><p>isCancelled()用来查看任务是否被取消成功，取消成功返回true否则false。</p></li>
<li><p>isDone()用来判断任务是否执行完。</p></li>
<li><p>get()用来获取执行结果。</p></li>
<li><p>get(timeout, unit)用来在执行时间内获取结果，超时返回null。</p></li>
</ul>

<p>由此可见，Future接口提供了三种功能：<br/>
1.判断任务是否完成。<br/>
2.设定是否中断任务。<br/>
3.可以获取任务的执行结果。</p>

<h4 id="toc_4">FutureTask</h4>

<p>FutureTask是RunnableFuture接口一种实现：</p>

<pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;
</code></pre>

<p>RunnableFuture接口继承了Runnable和Future接口，FutureTask实现了Runnable接口，它可以作为Runnable接口的实现被线程执行，又可以作为Future得到Callable的返回值。</p>

<pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
</code></pre>

<p>FutureTask有两个构造器方法，分别可以使用Callable和Runnable的实现。</p>

<pre><code>public FutureTask(Callable&lt;V&gt; callable) {
}
public FutureTask(Runnable runnable, V result) {
}
</code></pre>

<h4 id="toc_5">使用方法</h4>

<p>1)Callable+Future</p>

<pre><code>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future&lt;String&gt; result = executor.submit(task);
        executor.shutdown();
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println(&quot;main process is running&quot;);
         
        try {
            System.out.println(&quot;result:&quot;+result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println(&quot;all tasks finished&quot;);
    }
}
class Task implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        System.out.println(&quot;sub process is running&quot;);
        Thread.sleep(3000);
        
        return &quot;String result from call&quot;;
    }
}
</code></pre>

<p>2)Callable+FutureTask<br/>
FutureTask提供了使用Callable和Runnable两种实现。</p>

<pre><code>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Test {
    public static void main(String[] args) {
        //1.Callable+FutureTask
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(task);
        executor.submit(task);
        executor.shutdown();
        
        //2.Callable+FutureTask+Thread
        Task task = new Task();
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(task);
        Thread th = new Thread(ft);
        th.start();
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println(&quot;main process is running&quot;);
         
        try {
            System.out.println(&quot;result:&quot;+ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println(&quot;all tasks finished&quot;);
    }
}
class Task implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        System.out.println(&quot;sub process is running&quot;);
        Thread.sleep(3000);
        
        return &quot;String result from call&quot;;
    }
}
</code></pre>

<p>Callable接口与Runnable接口类似，区别如下：</p>

<table>
<thead>
<tr>
<th></th>
<th>Callable</th>
<th>Runnable</th>
</tr>
</thead>

<tbody>
<tr>
<td>返回值</td>
<td>提供</td>
<td>不提供</td>
</tr>
<tr>
<td>抛出异常</td>
<td>call()可以</td>
<td>run()不可以</td>
</tr>
<tr>
<td>异步计算结果</td>
<td>检查计算是否完成。 Future对象的get方法，阻塞线程</td>
<td>无</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[19. Static inner class 与non static inner class的区别]]></title>
    <link href="http://ranchu90.github.io/14751378304376.html"/>
    <updated>2016-09-29T16:30:30+08:00</updated>
    <id>http://ranchu90.github.io/14751378304376.html</id>
    <content type="html"><![CDATA[
<p>Java当中一种有四种内部类：</p>

<ul>
<li>静态内部类</li>
<li>普通内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>

<p>静态内部类(static inner class)</p>

<pre><code>class outerClass{
    //静态内部类
    static class staticInnerClass{
    }
    //普通内部类
    class innerClass{
    }
    //局部内部类
    public void function(){
        class innerClass{
        }
    }
    //匿名内部类
    public MyFrame() {
     addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
            ....
        }
    });
}
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th>静态内部类</th>
<th>普通内部类</th>
<th>局部内部类</th>
<th>匿名内部类</th>
</tr>
</thead>

<tbody>
<tr>
<td>实例化方式</td>
<td>不依赖外部类实例</td>
<td>依赖外部类实例</td>
<td>方法内部</td>
<td>只有一个实例</td>
</tr>
<tr>
<td>访问权限</td>
<td>外部静态成员和静态方法</td>
<td>外部所有成员方法</td>
<td>只能访问方法中final局部常量</td>
<td>同左</td>
</tr>
<tr>
<td>构造函数</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>其它</td>
<td></td>
<td></td>
<td>无publi,protected等修饰</td>
<td>同左；必须继承一个父类或者实现一个接口</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[18. interface与abstract类的区别]]></title>
    <link href="http://ranchu90.github.io/14751330832847.html"/>
    <updated>2016-09-29T15:11:23+08:00</updated>
    <id>http://ranchu90.github.io/14751330832847.html</id>
    <content type="html"><![CDATA[
<p>interface中不能有变量，只能有公有静态常量，没有构造方法，默认为public abstract，一个类可实现多个interface，表示has-a关系，实现一个接口必须实现其中所以的方法。</p>

<p>抽象类中可以有自己的变量，可以有私有方法和非抽象方法，需要继承，一个类只继承一个，继承类如果不是抽象类必须实现抽象方法，如果是则不需要被重写。is-a关系。</p>

<p>接口和抽象类的相同点：<br/>
1.都不能被实例化<br/>
2.接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化。</p>

<p>不同：<br/>
1.接口中的方法只能有定义。抽象类中可以有定义和实现。<br/>
2.接口可以实现（implement）多个，但是继承抽象类只能继承一个<br/>
3.接口中不能有变量只能包含public static final常量。所有方法默认为public abstract。抽象类中可以有普通成员变量和成员方法。<br/>
4.接口用于实现常用功能，便于日后维护或者添加删除方法；抽象类则充当公共类的角色，不适用于日后重新对代码进行修改。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[17. Override和Overload的含义去区别]]></title>
    <link href="http://ranchu90.github.io/14751246036816.html"/>
    <updated>2016-09-29T12:50:03+08:00</updated>
    <id>http://ranchu90.github.io/14751246036816.html</id>
    <content type="html"><![CDATA[
<p>Override<br/>
覆盖（又称重写）指重写父类的同名方法，参数，名称，返回值都必须一样，子类不能降低父类方法的可见性（否则无法实现多态）</p>

<p>Overload<br/>
重载，在同一个类中，使用同名方法，但方法参数必须有不同，个数或类型</p>

<pre><code>class Father{
    public void show(){
        System.out.println(&quot;Father&quot;);
    }
}

class Sub extends Father{
    
    public void show(){
        System.out.println(&quot;Sub&quot;);
    }
    
    public void show(String msg){
        System.out.println(&quot;reload:&quot; + msg);
    }
    
    public void show(String msg, String time){
        System.out.println(&quot;reload:&quot; + msg + &quot; time:&quot; + time);
    }
    
    public void show(int number){
        System.out.println(&quot;reload:&quot; + number);
    }
}
</code></pre>

<p>若子类尝试降覆盖方法的可见性，编译会报错。</p>

<pre><code>class Father{
    public void show(){
        System.out.println(&quot;Father&quot;);
    }
}

class Sub extends Father{
    
    private void show(){
        System.out.println(&quot;Sub&quot;);
    }
    
    public void show(String msg){
        System.out.println(&quot;reload:&quot; + msg);
    }
    
    public void show(String msg, String time){
        System.out.println(&quot;reload:&quot; + msg + &quot; time:&quot; + time);
    }
    
    public void show(int number){
        System.out.println(&quot;reload:&quot; + number);
    }
}
</code></pre>

<p>输出</p>

<pre><code>Untitled.java:9: 错误: Sub中的show()无法覆盖Father中的show()
    private void show(){
                 ^
  正在尝试分配更低的访问权限; 以前为public
1 个错误
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[16. Java面向对象的三个特征与含义]]></title>
    <link href="http://ranchu90.github.io/14751214147355.html"/>
    <updated>2016-09-29T11:56:54+08:00</updated>
    <id>http://ranchu90.github.io/14751214147355.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">封装</h3>

<p>封装：Java将现实中的对象抽象成一个类，并对它的属性和方法进行屏蔽保护，只允许特定的类可以访问，其它的进行隐藏，这个过程叫做封装。</p>

<h3 id="toc_1">继承</h3>

<p>继承：当两个类的关系是is-a的时候，可以考虑使用继承。它是一种层次结构，类的重用方式。当一个新类从现有类中派生出来，这个过程叫做继承。新类继承了原有类的属性和方法。缺点是继承树过于庞大之后,会导致子类继承后负担重,很多不需要的成员变量也被继承下来,整个类结构过于臃肿。</p>

<h3 id="toc_2">多态</h3>

<p>多态：允许不同类的对象对同一消息做出不同的响应。灵活抽象行为共享的优势。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>

<p>多态存在的三个必要条件<br/>
一、要有继承；<br/>
二、要有重写；<br/>
三、父类引用指向子类对象。</p>

<pre><code>class A {
    public void show(){
        System.out.println(&quot;This is A.&quot;);
    }
}

class B extends A{
    public void show(){
        System.out.println(&quot;This is B.&quot;);
    }
}

class C extends A{
    public void show(){
        System.out.println(&quot;This is C.&quot;);
    }
}

class Main {
    public static void main(String[] args) {
        A a = new A();
        a.show();
        A b = new B();
        b.show();
        A c = new C();
        c.show(); 
    }
}
</code></pre>

<p>输出</p>

<pre><code>This is A.
This is B.
This is C.
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[15. Exception与Error包结构。常见的OOM和SOF]]></title>
    <link href="http://ranchu90.github.io/14751149362443.html"/>
    <updated>2016-09-29T10:08:56+08:00</updated>
    <id>http://ranchu90.github.io/14751149362443.html</id>
    <content type="html"><![CDATA[
<p><img src="media/14751149362443/14751149641985.jpg" alt=""/></p>

<p>Java提供了两种错误的异常，分别为Exception和Error，它们继承自共同的父类Throwable。</p>

<h2 id="toc_0">Error</h2>

<p>Error表示程序在运行期间出现了非常严重的错误，且这个错误是不可恢复的。将导致程序终止执行。如OutOfMemoryError、ThreadDeath。错误发生时，JVM一般会终止程序的运行。</p>

<h2 id="toc_1">Exception</h2>

<p>Exception表示可恢复的异常，编译可以捕获。</p>

<p>1.检查异常（checked exception）<br/>
编译阶段发生，编译器强制在程序里捕获这类异常，放入try代码块中，把对异常的处理代码放到catch块中。常见的有IOException和SQLException。一般在以下情况中使用：<br/>
1）异常的发生并不导致程序出错，进行处理后可以继续执行后续的操作。<br/>
2）程序依赖于不可靠的外部条件，如IO。</p>

<p>2.运行时异常（runtime exception）<br/>
编译器不强制进行捕获。若不捕获的话，由JVM来处理。常见的运行时异常包括NullPointerException、ClassCastException、ArrayIndexOutOfBoundsException、StoreException、BufferOverflowException、ArithmeticException。</p>

<p>出现运行时异常之后，系统会将异常一直往上次抛出，知道遇到处理代码位置。若没有处理代码，则抛到最上层。多线程run()方法抛出，线程终止，或单线程main()方法抛出，整个程序退出。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[14. try catch finally，try里有return，finally还执行么]]></title>
    <link href="http://ranchu90.github.io/14750561415107.html"/>
    <updated>2016-09-28T17:49:01+08:00</updated>
    <id>http://ranchu90.github.io/14750561415107.html</id>
    <content type="html"><![CDATA[
<p>finally中的内容一定会执行的</p>

<pre><code>try{
    return 0;
} catch(Exception e){
    return 1;
} finally{
    return 2;
}
</code></pre>

<p>finally中的return会覆盖try，catch中的return，所以最后返回的是finally中的值</p>

<pre><code>class Main{
    public static String lem(){
        System.out.println(&quot;lem&quot;);
        return &quot;return from lem&quot;;
    }
    
    public static String foo(){
        int x = 0;
        int y = 5;
        try {
            System.out.println(&quot;start try&quot;);
            int b = y/x;
            System.out.println(&quot;end try&quot;);
            return &quot;return from try&quot;;
        } catch (Exception e) {
            System.out.println(&quot;catch&quot;);
            return lem() + &quot;| return from catch&quot;;
        } finally {
            System.out.println(&quot;finally&quot;);
            return &quot;return from finally&quot;;
        }
    }
    
    public static void main(String[] args) {
        String v = foo();
        
        System.out.println(v);
    }
}
</code></pre>

<p>输出：</p>

<pre><code>start try
catch
lem
finally
return from finally
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[12. TreeMap、HashMap、LinkedHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14750544918726.html"/>
    <updated>2016-09-28T17:21:31+08:00</updated>
    <id>http://ranchu90.github.io/14750544918726.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>TreeMap</th>
<th>LinkedHashMap</th>
</tr>
</thead>

<tbody>
<tr>
<td>遍历顺序</td>
<td>随机</td>
<td>实现了sortMap接口，按自然顺序或自定义顺序</td>
<td>与输入顺序相同</td>
</tr>
</tbody>
</table>

<p>weakHashMap与HashMap类似，它从用若引用，其中key不再被外部引用时即被JVM回收，HashMap采用强引用，key不被外部引用时，必须从Map中删除才能被GC回收</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[11. HashMap、Hashtable、ConcurrentHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14749678612341.html"/>
    <updated>2016-09-27T17:17:41+08:00</updated>
    <id>http://ranchu90.github.io/14749678612341.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">多线程下的HashMap</h2>

<p>HashMap是线程不安全的，在多线程环境中并发操作会存在以下问题：</p>

<ul>
<li>  多线程使用put()，触发resize(rehash)操作，创建多个newTable，再同时rehash，导致链表错乱。这时候，再使用get()操作将进入无线循环。getEntry获取table中的链表，链表成了一个循环链表，所以进入无线循环。</li>
</ul>

<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>

<ul>
<li>remove()，遍历map时调用remove，可能会导致丢失删除的数据后面的数据，跳到下一个槽位。</li>
</ul>

<h2 id="toc_1">ConcurrentHashMap和Hashtable</h2>

<p>concurrent,同时发生的。同时发生的hashmap，从名字就可以知道它专门用于多线程的情况。<br/>
它不同于hashtable，hashtable在方法前使用synchronized来保证同步这会导致被当一个对象被锁住的时候，另一个线程无法使用get()方法，而ConcurrentHashMap对map进行分段，在插入时使用段（继承自重用锁），来实现线程之间的同步。<br/>
但是在最新的java源码里我看到的是在put方法中使用synchronized块来实现同步。</p>

<pre><code> /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
</code></pre>

<p>以下三篇文章中有详细的说明可以参考下</p>

<p><a href="http://ifeve.com/concurrenthashmap/">http://ifeve.com/concurrenthashmap/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-1/">http://ifeve.com/java-concurrent-hashmap-1/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-2/">http://ifeve.com/java-concurrent-hashmap-2/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10. HashMap和HashTable的区别]]></title>
    <link href="http://ranchu90.github.io/14749657860314.html"/>
    <updated>2016-09-27T16:43:06+08:00</updated>
    <id>http://ranchu90.github.io/14749657860314.html</id>
    <content type="html"><![CDATA[
<p>Map<br/>
├Hashtable<br/>
├HashMap<br/>
└WeakHashMap</p>

<p>HashMap和HashTable都是Java中哈希表的实现方式。其中HashTable里的大多数方法比如add、remove..等前有synchronized修饰，所以它在多线程的环境下是线程安全的，也因此需要耗费性能在同步的问题上。而HashMap不是，所以它的效率较HashTable高。<br/>
HashMap中可以使用null作为key，这在HashTable中是不允许的。<br/>
HashMap中的contains方法因为语义不明改为containsKey()和containsValue()。<br/>
(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>

<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>

<tbody>
<tr>
<td>null作为key</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>contains()</td>
<td>改为containsKey() constainsValue()</td>
<td>继承Dicitionary</td>
</tr>
<tr>
<td>线程安全</td>
<td>否 效率较高</td>
<td>是 效率较低</td>
</tr>
<tr>
<td>迭代</td>
<td>iterator</td>
<td>enumeration</td>
</tr>
<tr>
<td>hash性能</td>
<td>几乎一样 使用hashcode()方法</td>
<td></td>
</tr>
<tr>
<td>hash值</td>
<td>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</td>
<td>直接hashcode方法的值</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9. Map、Set、List、Queue、Stack的特点与用法]]></title>
    <link href="http://ranchu90.github.io/14749474920939.html"/>
    <updated>2016-09-27T11:38:12+08:00</updated>
    <id>http://ranchu90.github.io/14749474920939.html</id>
    <content type="html"><![CDATA[
<p>Collections框架中包含了大量的集合接口及这些接口的实现。主要提供了9种Map、Set、List、Queue、Stack等数据结构。</p>

<ul>
<li>Set接口表示数学中集合的概念。其主要特点是集合中的元素不重复。</li>
<li>List接口表示有序的集合。它按照对象进入的顺序保存对象，所以能对每个元素的插入和删除具体的位置进行精确的控制。它能存放重复的对象。</li>
<li>Map接口提供了一个从Key到Value的数据结构，保存键值对。其中Value可以重复，但是Key不能重复。</li>
<li>Queue接口提供了“先进先出”队列的数据结构。只能在队尾添加元素，只能在对头弹出元素。</li>
<li>Stack继承自Vector，它实现了先进后出的栈结构。</li>
</ul>

<p>我在网络上找到一张实现Collection接口的类图，可以一目了然地看到实现的类及他们之间的关系。<br/>
<img src="media/14749474920939/14749600076300.jpg" alt=""/></p>

<p>Collection接口定义了一套统一的操作方法：</p>

<pre><code>int size();
返回容器中元素的个数
boolean isEmpty();
判断容器是否为空，空则返回true，否则false
boolean contains(Object o);
判段容器是否包含o对象
Iterator&lt;E&gt; iterator();
获得该容器的迭代器
Object[] toArray();
将容器转换为对象数组
boolean add(E e);
向容器中添加元素
boolean remove(Object o);
移除容器中的对象
boolean containsAll(Collection&lt;?&gt; c);
判断是否包含c中的所有元素
boolean addAll(Collection&lt;? extends E&gt; c);
添加c容器中的所有元素
boolean removeAll(Collection&lt;?&gt; c);
移除c中包含的所有元素
boolean retainAll(Collection&lt;?&gt; c);
保留c中存在的元素，移除c中不存在的元素
void clear();
清除容器中的所有元素
</code></pre>

<p>Stack类中除了继承了Vector的方法外还实现了</p>

<pre><code>boolean empty() 
测试堆栈是否为空。
Object peek( )
查看堆栈顶部的对象，但不从堆栈中移除它。
Object pop( )
移除堆栈顶部的对象，并作为此函数的值返回该对象。
Object push(Object element)
把项压入堆栈顶部。
int search(Object element)
返回对象在堆栈中的位置，以 1 为基数。
</code></pre>

<p>Queue接口中常用方法</p>

<pre><code>boolean add(E e);        
增加一个元素              若队列已满，则抛出一个IIIegaISlabEepeplian异常
boolean remove();   
移除并返回队列头部的元素    若队列为空，则抛出一个NoSuchElementException异常
E element()  
返回队列头部的元素         若队列为空，则抛出一个NoSuchElementException异常
offer(E e)      
添加一个元素并返回true     若队列已满，则返回false
E poll()      
移除并返问队列头部的元素    若队列为空，则返回null
E peek()     
返回队列头部的元素         若队列为空，则返回null
void put()     
添加一个元素              若队列满，则阻塞
void take()
移除并返回队列头部的元素    若队列为空，则阻塞
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[8. String、StringBuffer与StringBuilder的区别]]></title>
    <link href="http://ranchu90.github.io/14749467173553.html"/>
    <updated>2016-09-27T11:25:17+08:00</updated>
    <id>http://ranchu90.github.io/14749467173553.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>

<tbody>
<tr>
<td>可变性</td>
<td>不可变类</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td>线程安全</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>适用场合</td>
<td>被共享的场合 少量数据</td>
<td>经常修改的场合 避免附加操作 无用对象 提高效率 多线程大量数据</td>
<td>单线程下大量数据</td>
</tr>
<tr>
<td>构建</td>
<td>构造函数 ==赋值</td>
<td>构造函数</td>
<td>构造函数</td>
</tr>
<tr>
<td>执行效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
</feed>
