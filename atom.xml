<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[cd's blog]]></title>
  <link href="http://ranchu90.github.io/atom.xml" rel="self"/>
  <link href="http://ranchu90.github.io/"/>
  <updated>2016-09-29T12:35:41+08:00</updated>
  <id>http://ranchu90.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[25. ThreadLocal的设计理念与作用]]></title>
    <link href="http://ranchu90.github.io/14753108824439.html"/>
    <updated>2016-10-01T16:34:42+08:00</updated>
    <id>http://ranchu90.github.io/14753108824439.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">目的</h3>

<p>多线程共享一个变量，可以通过public static的形式来实现。<br/>
每一个线程都有自己的共享变量，提出ThreadLocal正是解决这样的问题。<br/>
ThreadLocal类主要解决每个线程绑定自己的值，打个比方，类似全局的存放数据的盒子，盒子中可以存放每个线程的私有数据。</p>

<h3 id="toc_1">常用的方法</h3>

<pre><code>T get();

void set(T value);

protected T initialValue() {
        return null;
}
</code></pre>

<p>get()用来获取本地线程中存放的值，set()用来设置本地线程中的值。<br/>
覆盖initialValue()可以设定指定的初始值，若不设定，初始值默认为null。</p>

<p>线程变量是隔离的，即每个线程只能访问自己的值，他们有各自的初始值。</p>

<h3 id="toc_2">InheritableThreadLocal</h3>

<p>使用InheritableThreadLocal可以继承父线程中的值，并可以通过覆盖childValue方法来修改继承的值。</p>

<h3 id="toc_3">示例</h3>

<pre><code>package com.cd.threadlocal;

public class Tools {

    public static ThreadLocalDefined&lt;String&gt; tl = new ThreadLocalDefined&lt;String&gt;();
    
    public Tools() {
        // TODO Auto-generated constructor stub
    }

}

package com.cd.threadlocal;

public class ThreadLocalDefined&lt;T&gt; extends ThreadLocal&lt;Object&gt; {

    @Override
    protected Object initialValue() {
        // TODO Auto-generated method stub
        return &quot;OK&quot;;
    }

}

package com.cd.threadlocal;

public class ThreadA extends Thread {

    public ThreadA() {
        // TODO Auto-generated constructor stub
    }

    @Override
    public void run() {
        for(int i=0; i&lt;10; ++i){
            if(Tools.tl.get() == null){
                System.out.println(&quot;ThreadA 1st &quot; + Tools.tl.get());
            }
            
            System.out.println(Tools.tl.get());
            Tools.tl.set(&quot;Thread A &quot;+ i);
        }
    }
}

package com.cd.threadlocal;

public class Main {

    public Main() {
        // TODO Auto-generated constructor stub
    }

    public static void main(String[] args) {
        
        ThreadA a = new ThreadA();
        a.start();
        
        for(int i=0; i&lt;10; ++i){
            if(Tools.tl.get() == null){
                System.out.println(&quot;Main 1st &quot; + Tools.tl.get());
            }
            
            System.out.println(Tools.tl.get());
            Tools.tl.set(&quot;Main Thread &quot;+i);
        }

    }

}

</code></pre>

<p>运行结果</p>

<pre><code>OK
OK
Main Thread 0
Thread A 0
Main Thread 1
Thread A 1
Thread A 2
Main Thread 2
Thread A 3
Main Thread 3
Thread A 4
Thread A 5
Main Thread 4
Thread A 6
Main Thread 5
Thread A 7
Main Thread 6
Thread A 8
Main Thread 7
Main Thread 8
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[24. 写出生产者消费者模式]]></title>
    <link href="http://ranchu90.github.io/14753034865723.html"/>
    <updated>2016-10-01T14:31:26+08:00</updated>
    <id>http://ranchu90.github.io/14753034865723.html</id>
    <content type="html"><![CDATA[
<p>参照网络上的资料，自己写了一个生产者消费者模式。</p>

<pre><code>package com.cd.test;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class Main {

    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        
        Container container = new Container();
        
        Producer a = new Producer(container, &quot;Wang Sir&quot;);
        Producer b = new Producer(container, &quot;Li Sir&quot;);
        Consumer c = new Consumer(container, &quot;Chen&quot;);
        Consumer d = new Consumer(container, &quot;Opp&quot;);
        Consumer e = new Consumer(container, &quot;Satoshi&quot;);
        
        service.submit(a);
        service.submit(b);
        service.submit(c);
        service.submit(d);
        service.submit(e);
    }

}

class Goods {
    int no;
    String producer;
    
    Goods(int no, String producer){
        this.no = no;
        this.producer = producer;
    }
    
    public String toString(){
        return &quot;product :&quot; + no + &quot; by &quot; + this.producer;
    }
}

class Container {
    BlockingQueue&lt;Goods&gt; queue = null;
    int index = 0;
    int max = 0;
    
    Container(int num){
        if(num &gt; 0){
            queue = new ArrayBlockingQueue&lt;Goods&gt;(num);
            max = num;
        }
        else{
            queue = new ArrayBlockingQueue&lt;Goods&gt;(10);
            max = 10;
        }
    }

    Container(){
        this(10);
    }
    
    synchronized public Goods pop() throws InterruptedException{
        if(queue == null || queue.isEmpty())
            return null;
        
        Goods tmp = queue.take();
        
        return tmp;
    }
    
    synchronized public boolean push(Goods good) throws InterruptedException{
        if(queue == null || queue.size() == max)
            return false;
        
        queue.put(good);
        
        return true;
    }
}

class Producer implements Runnable{
    Container container = null;
    String producer = null;
    
    Producer(Container ct, String producer){
        this.container = ct;
        this.producer = producer;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        int index = 0;
        
        while(index &lt; 5){
            Goods good = new Goods(index++, this.producer);
            
            try {
                container.push(good);
                System.out.println(&quot; Produced goods :&quot; + good.toString());
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
    
}

class Consumer implements Runnable{
    Container container = null;
    String producer = null;
    
    Consumer(Container ct, String producer){
        this.container = ct;
        this.producer = producer;
    }
    
    @Override
    public void run() {
        // TODO Auto-generated method stub
        while(true){
            Goods good;
            
            try {
                good = container.pop();
                
                System.out.println(&quot; Consumed goods :&quot; + good.toString());
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            
        }
    }
    
}
</code></pre>

<p>其中一次的运行结果</p>

<pre><code> Produced goods :product :0 by Wang Sir
 Produced goods :product :1 by Wang Sir
 Produced goods :product :2 by Wang Sir
 Produced goods :product :3 by Wang Sir
 Produced goods :product :4 by Wang Sir
 Produced goods :product :0 by Li Sir
 Produced goods :product :1 by Li Sir
 Consumed goods :product :0 by Wang Sir
 Consumed goods :product :0 by Li Sir
 Consumed goods :product :1 by Wang Sir
 Consumed goods :product :2 by Wang Sir
 Consumed goods :product :3 by Wang Sir
 Consumed goods :product :4 by Wang Sir
 Produced goods :product :2 by Li Sir
 Consumed goods :product :1 by Li Sir
 Consumed goods :product :2 by Li Sir
 Produced goods :product :3 by Li Sir
 Consumed goods :product :3 by Li Sir
 Produced goods :product :4 by Li Sir
 Consumed goods :product :4 by Li Sir

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[23. 锁的等级：方法锁、对象锁、类锁]]></title>
    <link href="http://ranchu90.github.io/14752943139261.html"/>
    <updated>2016-10-01T11:58:33+08:00</updated>
    <id>http://ranchu90.github.io/14752943139261.html</id>
    <content type="html"><![CDATA[
<p>synchornized锁的对象可以是方法、对象、和类。</p>

<p>比如</p>

<pre><code>class Test {
    public int share;
    public static share2;
    
    synchronized public void getShare(){
        
        Thread.sleep(5000);
        
        return share;
    }
    
    synchronized public void getShare2(){
        
        Thread.sleep(5000);
        
        return share;
    }
    
    public void print(){
        
        System.out.println(&quot;print test&quot;);
    }
    
    static public void print(String ok){
        
        System.out.println(&quot;print test : &quot; + ok);
    }
}
</code></pre>

<p>如果对Test的实例上锁，那么其它的线程就无法访问该实例的synchronized方法，但是可以访问该实例没有synchronized的方法和静态的方法。<br/>
如果该方法内部调用了wait()方法，那么其它的线程可以访问该对象的synchronized方法。</p>

<p>如果对Test这个类上锁，那么该类的静态方法不能被其它的线程访问。但是实例方法可以被访问到，如果该实例为被上锁的话。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[22. 线程同步的方法：synchronized、lock、reentrantLock]]></title>
    <link href="http://ranchu90.github.io/14752937281313.html"/>
    <updated>2016-10-01T11:48:48+08:00</updated>
    <id>http://ranchu90.github.io/14752937281313.html</id>
    <content type="html"><![CDATA[
<p>sychronized用法两种1)锁方法2）锁对象（sychronized块），可作用于静态方法、类、实例。对效率有较大影响。</p>

<p>Lock是jdk5新增的一个接口，reentrantLock是它的一个实现类。</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>lock()</td>
<td>以阻塞的方式获取锁</td>
</tr>
<tr>
<td>tryLock()</td>
<td>以非阻塞的方式获取。如取得锁立即返回true，否则false。</td>
</tr>
<tr>
<td>tryLock(long timeout, TimeOut unit)</td>
<td>取得锁返回true；否则等待给定的单元时间，等待中获得锁返回true，等待结束，返回fasle。</td>
</tr>
<tr>
<td>lockInterruptibly()</td>
<td>获得所立即返回，否则当前线程处于阻塞状态直到获得锁，这个过程中，该线程可以被别的线程中断(InterruptedException)</td>
</tr>
</tbody>
</table>

<p>synchronized和lock的区别<br/>
总的来说可以从用法，性能，锁的机制及功能上来区别。</p>

<table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>lock</th>
</tr>
</thead>

<tbody>
<tr>
<td>用法</td>
<td>需要同步的对象中，1）锁方法，2）特定的代码块(锁对象或类），给JVM托管</td>
<td>需要显示地指定起始位置和终止位置。更精准的线程语义</td>
</tr>
<tr>
<td>性能</td>
<td>资源竞争不激烈时，优于lock，激烈时，性能下降很快</td>
<td>ReentrantLock性能比较稳定</td>
</tr>
<tr>
<td>锁机制</td>
<td>锁的获得与释放都在块结构中，获得多个锁，以相反的顺序释放，自动释放</td>
<td>手动释放做，必须在finally中释放。</td>
</tr>
<tr>
<td>功能</td>
<td>无法非阻塞获取锁，进入临界区无法中断，必须阻塞等待释放资源</td>
<td>包含synchronized的功能，提供非阻塞方式获取所、可中断线程的功能</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[21. 实现多线程的两种方法：Thread与Runnable]]></title>
    <link href="http://ranchu90.github.io/14752420902330.html"/>
    <updated>2016-09-30T21:28:10+08:00</updated>
    <id>http://ranchu90.github.io/14752420902330.html</id>
    <content type="html"><![CDATA[
<p>实现多线程在java中有三种方法，前两种比较常用。</p>

<h3 id="toc_0">继承Thread</h3>

<p>1）继承Thread类，重写run方法</p>

<pre><code>class MyThread extends Thread {
    @Override
    public void run(){
        
    }
}
</code></pre>

<h3 id="toc_1">实现Runnable</h3>

<p>2）实现Runnable接口<br/>
1.重写run方法，实例化后，再创建一个Thread的对象，将其传入Thread（object）方法中<br/>
2.创建一个Thread对象，使用匿名内部类实现Runnable接口。</p>

<p>Runnable接口中只声明了一个方法，返回类型为void。</p>

<pre><code>public interface Runnable {
    public abstract void run();
}
</code></pre>

<pre><code>class MyThread implements Runnable {
    @Override
    public void run(){
        System.out.println(&quot;runnable&quot;);
    }
}

class Main {
    public static void main(String[] args) {
        MyThread th = new MyThread();
        Thread run = new Thread(th);
        Thread run2 = new Thread(new Runnable(){
            public void run(){
                System.out.println(&quot;inner runnable&quot;);
            }
        });
        
        run.start();
        run2.start();
    }
}
</code></pre>

<h3 id="toc_2">实现Callable</h3>

<p>3）实现Callable（）接口，重写Call方法。<br/>
前两种创建线程的方式都包含一个缺陷，在执行完任务后无法获得执行结果。如果要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果。</p>

<p>Callable接口位于java.util.concurrent下，只包含一个方法。</p>

<pre><code>public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
</code></pre>

<p>Callable一般配合ExecutorService接口中的submit方法来使用。</p>

<pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
Future&lt;?&gt; submit(Runnable task);
</code></pre>

<h4 id="toc_3">Future</h4>

<p>java.util.concurrent<br/>
Future用于对具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。可以通过get()获取其执行结果，这个方法或阻塞知道获得任务返回的结果。</p>

<pre><code>public interface Future&lt;V&gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>

<ul>
<li><p>cancel用来取消任务，若取消成功则返回true，取消失败则返回false。mayInterruptIfRunning用于表示是否取消（中断）正在执行却没有完成的任务，true表示可以取消。任务未开始执行和任务执行完成时，无论其值为true或false，都返回false，取消失败。若果任务正在执行，其值为true，则返回true，其值为false，则返回fasle。</p></li>
<li><p>isCancelled()用来查看任务是否被取消成功，取消成功返回true否则false。</p></li>
<li><p>isDone()用来判断任务是否执行完。</p></li>
<li><p>get()用来获取执行结果。</p></li>
<li><p>get(timeout, unit)用来在执行时间内获取结果，超时返回null。</p></li>
</ul>

<p>由此可见，Future接口提供了三种功能：<br/>
1.判断任务是否完成。<br/>
2.设定是否中断任务。<br/>
3.可以获取任务的执行结果。</p>

<h4 id="toc_4">FutureTask</h4>

<p>FutureTask是RunnableFuture接口一种实现：</p>

<pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;
</code></pre>

<p>RunnableFuture接口继承了Runnable和Future接口，FutureTask实现了Runnable接口，它可以作为Runnable接口的实现被线程执行，又可以作为Future得到Callable的返回值。</p>

<pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
</code></pre>

<p>FutureTask有两个构造器方法，分别可以使用Callable和Runnable的实现。</p>

<pre><code>public FutureTask(Callable&lt;V&gt; callable) {
}
public FutureTask(Runnable runnable, V result) {
}
</code></pre>

<h4 id="toc_5">使用方法</h4>

<p>1)Callable+Future</p>

<pre><code>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future&lt;String&gt; result = executor.submit(task);
        executor.shutdown();
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println(&quot;main process is running&quot;);
         
        try {
            System.out.println(&quot;result:&quot;+result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println(&quot;all tasks finished&quot;);
    }
}
class Task implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        System.out.println(&quot;sub process is running&quot;);
        Thread.sleep(3000);
        
        return &quot;String result from call&quot;;
    }
}
</code></pre>

<p>2)Callable+FutureTask<br/>
FutureTask提供了使用Callable和Runnable两种实现。</p>

<pre><code>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Test {
    public static void main(String[] args) {
        //1.Callable+FutureTask
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(task);
        executor.submit(task);
        executor.shutdown();
        
        //2.Callable+FutureTask+Thread
        Task task = new Task();
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(task);
        Thread th = new Thread(ft);
        th.start();
         
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
         
        System.out.println(&quot;main process is running&quot;);
         
        try {
            System.out.println(&quot;result:&quot;+ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
         
        System.out.println(&quot;all tasks finished&quot;);
    }
}
class Task implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        System.out.println(&quot;sub process is running&quot;);
        Thread.sleep(3000);
        
        return &quot;String result from call&quot;;
    }
}
</code></pre>

<p>Callable接口与Runnable接口类似，区别如下：</p>

<table>
<thead>
<tr>
<th></th>
<th>Callable</th>
<th>Runnable</th>
</tr>
</thead>

<tbody>
<tr>
<td>返回值</td>
<td>提供</td>
<td>不提供</td>
</tr>
<tr>
<td>抛出异常</td>
<td>call()可以</td>
<td>run()不可以</td>
</tr>
<tr>
<td>异步计算结果</td>
<td>检查计算是否完成。 Future对象的get方法，阻塞线程</td>
<td>无</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[19. Static inner class 与non static inner class的区别]]></title>
    <link href="http://ranchu90.github.io/14751378304376.html"/>
    <updated>2016-09-29T16:30:30+08:00</updated>
    <id>http://ranchu90.github.io/14751378304376.html</id>
    <content type="html"><![CDATA[
<p>Java当中一种有四种内部类：</p>

<ul>
<li>静态内部类</li>
<li>普通内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>

<p>静态内部类(static inner class)</p>

<pre><code>class outerClass{
    //静态内部类
    static class staticInnerClass{
    }
    //普通内部类
    class innerClass{
    }
    //局部内部类
    public void function(){
        class innerClass{
        }
    }
    //匿名内部类
    public MyFrame() {
     addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
            ....
        }
    });
}
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th>静态内部类</th>
<th>普通内部类</th>
<th>局部内部类</th>
<th>匿名内部类</th>
</tr>
</thead>

<tbody>
<tr>
<td>实例化方式</td>
<td>不依赖外部类实例</td>
<td>依赖外部类实例</td>
<td>方法内部</td>
<td>只有一个实例</td>
</tr>
<tr>
<td>访问权限</td>
<td>外部静态成员和静态方法</td>
<td>外部所有成员方法</td>
<td>只能访问方法中final局部常量</td>
<td>同左</td>
</tr>
<tr>
<td>构造函数</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>其它</td>
<td></td>
<td></td>
<td>无publi,protected等修饰</td>
<td>同左；必须继承一个父类或者实现一个接口</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[18. interface与abstract类的区别]]></title>
    <link href="http://ranchu90.github.io/14751330832847.html"/>
    <updated>2016-09-29T15:11:23+08:00</updated>
    <id>http://ranchu90.github.io/14751330832847.html</id>
    <content type="html"><![CDATA[
<p>interface中不能有变量，只能有公有静态常量，没有构造方法，默认为public abstract，一个类可实现多个interface，表示has-a关系，实现一个接口必须实现其中所以的方法。</p>

<p>抽象类中可以有自己的变量，可以有私有方法和非抽象方法，需要继承，一个类只继承一个，继承类如果不是抽象类必须实现抽象方法，如果是则不需要被重写。is-a关系。</p>

<p>接口和抽象类的相同点：<br/>
1.都不能被实例化<br/>
2.接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化。</p>

<p>不同：<br/>
1.接口中的方法只能有定义。抽象类中可以有定义和实现。<br/>
2.接口可以实现（implement）多个，但是继承抽象类只能继承一个<br/>
3.接口中不能有变量只能包含public static final常量。所有方法默认为public abstract。抽象类中可以有普通成员变量和成员方法。<br/>
4.接口用于实现常用功能，便于日后维护或者添加删除方法；抽象类则充当公共类的角色，不适用于日后重新对代码进行修改。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[17. Override和Overload的含义去区别]]></title>
    <link href="http://ranchu90.github.io/14751246036816.html"/>
    <updated>2016-09-29T12:50:03+08:00</updated>
    <id>http://ranchu90.github.io/14751246036816.html</id>
    <content type="html"><![CDATA[
<p>Override<br/>
覆盖（又称重写）指重写父类的同名方法，参数，名称，返回值都必须一样，子类不能降低父类方法的可见性（否则无法实现多态）</p>

<p>Overload<br/>
重载，在同一个类中，使用同名方法，但方法参数必须有不同，个数或类型</p>

<pre><code>class Father{
    public void show(){
        System.out.println(&quot;Father&quot;);
    }
}

class Sub extends Father{
    
    public void show(){
        System.out.println(&quot;Sub&quot;);
    }
    
    public void show(String msg){
        System.out.println(&quot;reload:&quot; + msg);
    }
    
    public void show(String msg, String time){
        System.out.println(&quot;reload:&quot; + msg + &quot; time:&quot; + time);
    }
    
    public void show(int number){
        System.out.println(&quot;reload:&quot; + number);
    }
}
</code></pre>

<p>若子类尝试降覆盖方法的可见性，编译会报错。</p>

<pre><code>class Father{
    public void show(){
        System.out.println(&quot;Father&quot;);
    }
}

class Sub extends Father{
    
    private void show(){
        System.out.println(&quot;Sub&quot;);
    }
    
    public void show(String msg){
        System.out.println(&quot;reload:&quot; + msg);
    }
    
    public void show(String msg, String time){
        System.out.println(&quot;reload:&quot; + msg + &quot; time:&quot; + time);
    }
    
    public void show(int number){
        System.out.println(&quot;reload:&quot; + number);
    }
}
</code></pre>

<p>输出</p>

<pre><code>Untitled.java:9: 错误: Sub中的show()无法覆盖Father中的show()
    private void show(){
                 ^
  正在尝试分配更低的访问权限; 以前为public
1 个错误
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[16. Java面向对象的三个特征与含义]]></title>
    <link href="http://ranchu90.github.io/14751214147355.html"/>
    <updated>2016-09-29T11:56:54+08:00</updated>
    <id>http://ranchu90.github.io/14751214147355.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">封装</h3>

<p>封装：Java将现实中的对象抽象成一个类，并对它的属性和方法进行屏蔽保护，只允许特定的类可以访问，其它的进行隐藏，这个过程叫做封装。</p>

<h3 id="toc_1">继承</h3>

<p>继承：当两个类的关系是is-a的时候，可以考虑使用继承。它是一种层次结构，类的重用方式。当一个新类从现有类中派生出来，这个过程叫做继承。新类继承了原有类的属性和方法。缺点是继承树过于庞大之后,会导致子类继承后负担重,很多不需要的成员变量也被继承下来,整个类结构过于臃肿。</p>

<h3 id="toc_2">多态</h3>

<p>多态：允许不同类的对象对同一消息做出不同的响应。灵活抽象行为共享的优势。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>

<p>多态存在的三个必要条件<br/>
一、要有继承；<br/>
二、要有重写；<br/>
三、父类引用指向子类对象。</p>

<pre><code>class A {
    public void show(){
        System.out.println(&quot;This is A.&quot;);
    }
}

class B extends A{
    public void show(){
        System.out.println(&quot;This is B.&quot;);
    }
}

class C extends A{
    public void show(){
        System.out.println(&quot;This is C.&quot;);
    }
}

class Main {
    public static void main(String[] args) {
        A a = new A();
        a.show();
        A b = new B();
        b.show();
        A c = new C();
        c.show(); 
    }
}
</code></pre>

<p>输出</p>

<pre><code>This is A.
This is B.
This is C.
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[15. Exception与Error包结构。常见的OOM和SOF]]></title>
    <link href="http://ranchu90.github.io/14751149362443.html"/>
    <updated>2016-09-29T10:08:56+08:00</updated>
    <id>http://ranchu90.github.io/14751149362443.html</id>
    <content type="html"><![CDATA[
<p><img src="media/14751149362443/14751149641985.jpg" alt=""/></p>

<p>Java提供了两种错误的异常，分别为Exception和Error，它们继承自共同的父类Throwable。</p>

<h2 id="toc_0">Error</h2>

<p>Error表示程序在运行期间出现了非常严重的错误，且这个错误是不可恢复的。将导致程序终止执行。如OutOfMemoryError、ThreadDeath。错误发生时，JVM一般会终止程序的运行。</p>

<h2 id="toc_1">Exception</h2>

<p>Exception表示可恢复的异常，编译可以捕获。</p>

<p>1.检查异常（checked exception）<br/>
编译阶段发生，编译器强制在程序里捕获这类异常，放入try代码块中，把对异常的处理代码放到catch块中。常见的有IOException和SQLException。一般在以下情况中使用：<br/>
1）异常的发生并不导致程序出错，进行处理后可以继续执行后续的操作。<br/>
2）程序依赖于不可靠的外部条件，如IO。</p>

<p>2.运行时异常（runtime exception）<br/>
编译器不强制进行捕获。若不捕获的话，由JVM来处理。常见的运行时异常包括NullPointerException、ClassCastException、ArrayIndexOutOfBoundsException、StoreException、BufferOverflowException、ArithmeticException。</p>

<p>出现运行时异常之后，系统会将异常一直往上次抛出，知道遇到处理代码位置。若没有处理代码，则抛到最上层。多线程run()方法抛出，线程终止，或单线程main()方法抛出，整个程序退出。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[14. try catch finally，try里有return，finally还执行么]]></title>
    <link href="http://ranchu90.github.io/14750561415107.html"/>
    <updated>2016-09-28T17:49:01+08:00</updated>
    <id>http://ranchu90.github.io/14750561415107.html</id>
    <content type="html"><![CDATA[
<p>finally中的内容一定会执行的</p>

<pre><code>try{
    return 0;
} catch(Exception e){
    return 1;
} finally{
    return 2;
}
</code></pre>

<p>finally中的return会覆盖try，catch中的return，所以最后返回的是finally中的值</p>

<pre><code>class Main{
    public static String lem(){
        System.out.println(&quot;lem&quot;);
        return &quot;return from lem&quot;;
    }
    
    public static String foo(){
        int x = 0;
        int y = 5;
        try {
            System.out.println(&quot;start try&quot;);
            int b = y/x;
            System.out.println(&quot;end try&quot;);
            return &quot;return from try&quot;;
        } catch (Exception e) {
            System.out.println(&quot;catch&quot;);
            return lem() + &quot;| return from catch&quot;;
        } finally {
            System.out.println(&quot;finally&quot;);
            return &quot;return from finally&quot;;
        }
    }
    
    public static void main(String[] args) {
        String v = foo();
        
        System.out.println(v);
    }
}
</code></pre>

<p>输出：</p>

<pre><code>start try
catch
lem
finally
return from finally
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[12. TreeMap、HashMap、LinkedHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14750544918726.html"/>
    <updated>2016-09-28T17:21:31+08:00</updated>
    <id>http://ranchu90.github.io/14750544918726.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>TreeMap</th>
<th>LinkedHashMap</th>
</tr>
</thead>

<tbody>
<tr>
<td>遍历顺序</td>
<td>随机</td>
<td>实现了sortMap接口，按自然顺序或自定义顺序</td>
<td>与输入顺序相同</td>
</tr>
</tbody>
</table>

<p>weakHashMap与HashMap类似，它从用若引用，其中key不再被外部引用时即被JVM回收，HashMap采用强引用，key不被外部引用时，必须从Map中删除才能被GC回收</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[11. HashMap、Hashtable、ConcurrentHashMap的区别]]></title>
    <link href="http://ranchu90.github.io/14749678612341.html"/>
    <updated>2016-09-27T17:17:41+08:00</updated>
    <id>http://ranchu90.github.io/14749678612341.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">多线程下的HashMap</h2>

<p>HashMap是线程不安全的，在多线程环境中并发操作会存在以下问题：</p>

<ul>
<li>  多线程使用put()，触发resize(rehash)操作，创建多个newTable，再同时rehash，导致链表错乱。这时候，再使用get()操作将进入无线循环。getEntry获取table中的链表，链表成了一个循环链表，所以进入无线循环。</li>
</ul>

<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>

<ul>
<li>remove()，遍历map时调用remove，可能会导致丢失删除的数据后面的数据，跳到下一个槽位。</li>
</ul>

<h2 id="toc_1">ConcurrentHashMap和Hashtable</h2>

<p>concurrent,同时发生的。同时发生的hashmap，从名字就可以知道它专门用于多线程的情况。<br/>
它不同于hashtable，hashtable在方法前使用synchronized来保证同步这会导致被当一个对象被锁住的时候，另一个线程无法使用get()方法，而ConcurrentHashMap对map进行分段，在插入时使用段（继承自重用锁），来实现线程之间的同步。<br/>
但是在最新的java源码里我看到的是在put方法中使用synchronized块来实现同步。</p>

<pre><code> /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
</code></pre>

<p>以下三篇文章中有详细的说明可以参考下</p>

<p><a href="http://ifeve.com/concurrenthashmap/">http://ifeve.com/concurrenthashmap/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-1/">http://ifeve.com/java-concurrent-hashmap-1/</a><br/>
<a href="http://ifeve.com/java-concurrent-hashmap-2/">http://ifeve.com/java-concurrent-hashmap-2/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10. HashMap和HashTable的区别]]></title>
    <link href="http://ranchu90.github.io/14749657860314.html"/>
    <updated>2016-09-27T16:43:06+08:00</updated>
    <id>http://ranchu90.github.io/14749657860314.html</id>
    <content type="html"><![CDATA[
<p>Map<br/>
├Hashtable<br/>
├HashMap<br/>
└WeakHashMap</p>

<p>HashMap和HashTable都是Java中哈希表的实现方式。其中HashTable里的大多数方法比如add、remove..等前有synchronized修饰，所以它在多线程的环境下是线程安全的，也因此需要耗费性能在同步的问题上。而HashMap不是，所以它的效率较HashTable高。<br/>
HashMap中可以使用null作为key，这在HashTable中是不允许的。<br/>
HashMap中的contains方法因为语义不明改为containsKey()和containsValue()。<br/>
(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>

<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>

<tbody>
<tr>
<td>null作为key</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>contains()</td>
<td>改为containsKey() constainsValue()</td>
<td>继承Dicitionary</td>
</tr>
<tr>
<td>线程安全</td>
<td>否 效率较高</td>
<td>是 效率较低</td>
</tr>
<tr>
<td>迭代</td>
<td>iterator</td>
<td>enumeration</td>
</tr>
<tr>
<td>hash性能</td>
<td>几乎一样 使用hashcode()方法</td>
<td></td>
</tr>
<tr>
<td>hash值</td>
<td>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</td>
<td>直接hashcode方法的值</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9. Map、Set、List、Queue、Stack的特点与用法]]></title>
    <link href="http://ranchu90.github.io/14749474920939.html"/>
    <updated>2016-09-27T11:38:12+08:00</updated>
    <id>http://ranchu90.github.io/14749474920939.html</id>
    <content type="html"><![CDATA[
<p>Collections框架中包含了大量的集合接口及这些接口的实现。主要提供了9种Map、Set、List、Queue、Stack等数据结构。</p>

<ul>
<li>Set接口表示数学中集合的概念。其主要特点是集合中的元素不重复。</li>
<li>List接口表示有序的集合。它按照对象进入的顺序保存对象，所以能对每个元素的插入和删除具体的位置进行精确的控制。它能存放重复的对象。</li>
<li>Map接口提供了一个从Key到Value的数据结构，保存键值对。其中Value可以重复，但是Key不能重复。</li>
<li>Queue接口提供了“先进先出”队列的数据结构。只能在队尾添加元素，只能在对头弹出元素。</li>
<li>Stack继承自Vector，它实现了先进后出的栈结构。</li>
</ul>

<p>我在网络上找到一张实现Collection接口的类图，可以一目了然地看到实现的类及他们之间的关系。<br/>
<img src="media/14749474920939/14749600076300.jpg" alt=""/></p>

<p>Collection接口定义了一套统一的操作方法：</p>

<pre><code>int size();
返回容器中元素的个数
boolean isEmpty();
判断容器是否为空，空则返回true，否则false
boolean contains(Object o);
判段容器是否包含o对象
Iterator&lt;E&gt; iterator();
获得该容器的迭代器
Object[] toArray();
将容器转换为对象数组
boolean add(E e);
向容器中添加元素
boolean remove(Object o);
移除容器中的对象
boolean containsAll(Collection&lt;?&gt; c);
判断是否包含c中的所有元素
boolean addAll(Collection&lt;? extends E&gt; c);
添加c容器中的所有元素
boolean removeAll(Collection&lt;?&gt; c);
移除c中包含的所有元素
boolean retainAll(Collection&lt;?&gt; c);
保留c中存在的元素，移除c中不存在的元素
void clear();
清除容器中的所有元素
</code></pre>

<p>Stack类中除了继承了Vector的方法外还实现了</p>

<pre><code>boolean empty() 
测试堆栈是否为空。
Object peek( )
查看堆栈顶部的对象，但不从堆栈中移除它。
Object pop( )
移除堆栈顶部的对象，并作为此函数的值返回该对象。
Object push(Object element)
把项压入堆栈顶部。
int search(Object element)
返回对象在堆栈中的位置，以 1 为基数。
</code></pre>

<p>Queue接口中常用方法</p>

<pre><code>boolean add(E e);        
增加一个元素              若队列已满，则抛出一个IIIegaISlabEepeplian异常
boolean remove();   
移除并返回队列头部的元素    若队列为空，则抛出一个NoSuchElementException异常
E element()  
返回队列头部的元素         若队列为空，则抛出一个NoSuchElementException异常
offer(E e)      
添加一个元素并返回true     若队列已满，则返回false
E poll()      
移除并返问队列头部的元素    若队列为空，则返回null
E peek()     
返回队列头部的元素         若队列为空，则返回null
void put()     
添加一个元素              若队列满，则阻塞
void take()
移除并返回队列头部的元素    若队列为空，则阻塞
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[8. String、StringBuffer与StringBuilder的区别]]></title>
    <link href="http://ranchu90.github.io/14749467173553.html"/>
    <updated>2016-09-27T11:25:17+08:00</updated>
    <id>http://ranchu90.github.io/14749467173553.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th></th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>

<tbody>
<tr>
<td>可变性</td>
<td>不可变类</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td>线程安全</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>适用场合</td>
<td>被共享的场合 少量数据</td>
<td>经常修改的场合 避免附加操作 无用对象 提高效率 多线程大量数据</td>
<td>单线程下大量数据</td>
</tr>
<tr>
<td>构建</td>
<td>构造函数 ==赋值</td>
<td>构造函数</td>
<td>构造函数</td>
</tr>
<tr>
<td>执行效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7. ArrayList、LinkedList、Vector的区别]]></title>
    <link href="http://ranchu90.github.io/14748992011687.html"/>
    <updated>2016-09-26T22:13:21+08:00</updated>
    <id>http://ranchu90.github.io/14748992011687.html</id>
    <content type="html"><![CDATA[
<p>Collection包结构，Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法。实现该接口的类主要有List和Set，其目的在于为各种具体的集合提供最大化的统一的操作方式。<br/>
Collection包结构</p>

<pre><code>Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set
</code></pre>

<p>ArrayList和Vector是顺序存储（物理上连续的内存空间）的集合，使用的时候可以根据下标进行访问，索引数据的效率高。但是在删除或者插入时，需要移动容器中的元素，因此插入删除时，效率低。<br/>
另外，Vector的大多数方法前都有synchronized关键字，因此是线程安全的，ArrayList则不是。</p>

<p>容量扩充：当ArrayList或Vector中设定的容量不够容纳新的节点时，会自动调用grow()方法进行容量的扩充。ArrayList默认扩充原来大小的1.5倍。Vector默认扩充原来大小的2倍，指定capacityIncrement的话，每次扩充指定的大小。</p>

<pre><code>//ArrayList
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
//LinkedList
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
</code></pre>

<p>LinkedList采用双向链表实现，无法使用下标访问。每次由下标获取元素的时候，先判断其在前半段还是后半段，在前半段从头结点开始查找，在后半段从尾节点从后往前查找。因此，查找时，效率较ArrayList和Vector低。但是插入或者删除操作，只需要进行节点的删除或者连接操作，因此效率较前二者高。</p>

<pre><code>Node&lt;E&gt; node(int index) {
        // assert isElementIndex(index);

        if (index &lt; (size &gt;&gt; 1)) {
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6. Hashcode的作用]]></title>
    <link href="http://ranchu90.github.io/14748977980780.html"/>
    <updated>2016-09-26T21:49:58+08:00</updated>
    <id>http://ranchu90.github.io/14748977980780.html</id>
    <content type="html"><![CDATA[
<p>1.在HashMap、HashTable..等集合类中，采用邻接矩阵的数据结构实现，hashCode()值用来散列存储结构中确定对象的存储地址。</p>

<p>2.找到目标地址后，在链表的遍历中使用equals()方法判断两个对象的内容是否相同。</p>

<p>3.如果equals()被重写，那么该对象的hashCode()也要被重写，以保证2中的条件成立。</p>

<p>4.由邻接矩阵的结构可知，hashCode值相同的对象，其内容不一定相同，只能说明他们存放在同一条链表中。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5. Java的四种引用，强弱软虚，用到的场景]]></title>
    <link href="http://ranchu90.github.io/14748971773098.html"/>
    <updated>2016-09-26T21:39:37+08:00</updated>
    <id>http://ranchu90.github.io/14748971773098.html</id>
    <content type="html"><![CDATA[
<p>Java对对象的引用分为四种：<br/>
1.强引用。强引用的对象不会被垃圾回收器回收。内存不足时，宁可抛出OOM错误也不会回收强引用。</p>

<p>2.软引用。可有可无的引用，当JVM内存足够的时候不会被回收；当JVM内存不足的时候，发现软引用的存在，会回收软引用。</p>

<p>3.若引用。可有可无的引用，一旦被垃圾回收器发现，马上就被其回收。</p>

<p>4.幽灵引用。它一般用来标记被回收的对象，当对象被回收后，会受到一条消息。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4.Object有哪些公用方法？]]></title>
    <link href="http://ranchu90.github.io/14748970236814.html"/>
    <updated>2016-09-26T21:37:03+08:00</updated>
    <id>http://ranchu90.github.io/14748970236814.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1．clone方法</h2>

<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>

<h2 id="toc_1">2．getClass方法</h2>

<p>final方法，获得运行时类型。</p>

<h2 id="toc_2">3．toString方法</h2>

<p>该方法用得比较多，一般子类都有覆盖。</p>

<h2 id="toc_3">4．finalize方法</h2>

<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。自动垃圾收集 器 会 调用 finalize() 方法。</p>

<h2 id="toc_4">5．equals方法</h2>

<p>该方法是非常重要的一个方法。一般equals和<code>==</code>是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>

<h2 id="toc_5">6．hashCode方法</h2>

<p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。<br/>
一般必须满足obj1.equals(obj2)<code>==</code>true。可以推出obj1.hashCode()<code>==</code>obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>

<h2 id="toc_6">7．wait方法</h2>

<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br/>
调用该方法后当前线程进入睡眠状态，直到以下事件发生。<br/>
（1）其他线程调用了该对象的notify方法。<br/>
（2）其他线程调用了该对象的notifyAll方法。<br/>
（3）其他线程调用了interrupt中断该线程。<br/>
（4）时间间隔到了。<br/>
此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>

<h2 id="toc_7">8．notify方法</h2>

<p>该方法唤醒在该对象上等待的某个线程。</p>

<h2 id="toc_8">9．notifyAll方法</h2>

<p>该方法唤醒在该对象上等待的所有线程。</p>

]]></content>
  </entry>
  
</feed>
